<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #AFDBE3; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #AFDBE3, 0 0 5px     #AFDBE3; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #AFDBE3;    /*上边框颜色*/
        border-left-color: #AFDBE3;    /*左边框颜色*/
    }
</style>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript初探," />










<meta name="keywords" content="JavaScript初探">
<meta property="og:type" content="article">
<meta property="og:title" content="JS初探九（JS中的函数）">
<meta property="og:url" content="http://www.github.com/Snowyzdx/JavaScript/JS初探九（JS中的函数）/index.html">
<meta property="og:site_name" content="Snowy&#39;blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/jsJichujsa09.png">
<meta property="og:updated_time" content="2018-05-02T10:19:23.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS初探九（JS中的函数）">
<meta name="twitter:image" content="http://p6nfblqvu.bkt.clouddn.com/jsJichujsa09.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="http://www.github.com/Snowyzdx/JavaScript/JS初探九（JS中的函数）/"/>





  <title>JS初探九（JS中的函数） | Snowy'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Asiazdx"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Snowy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Stay Hungry. Stay Foolish</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-comments">
          <a href="/comments/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heart"></i> <br />
            
            留言板
          </a>
        </li>
      
        
        <li class="menu-item menu-item-laboratory">
          <a href="/laboratory/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />
            
            实验室
          </a>
        </li>
      
        
        <li class="menu-item menu-item-other_note">
          <a href="/other_note/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书影音
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.github.com/Snowyzdx/JavaScript/JS初探九（JS中的函数）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="稻香Snowy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Snowy'blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JS初探九（JS中的函数）</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-09T09:44:46+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://p6nfblqvu.bkt.clouddn.com/jsJichujsa09.png" width="600" alt="jsa09"><br><a id="more"></a></p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-函数的声明"><a href="#1-函数的声明" class="headerlink" title="1.函数的声明"></a>1.函数的声明</h3><p>javascript有三种声明函数的方法。    </p>
<h4 id="（1）、function命令"><a href="#（1）、function命令" class="headerlink" title="（1）、function命令"></a>（1）、function命令</h4><p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一个圆括号，里面出入函数的参数。函数体放在大括号里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式叫做函数的声明。   </p>
<h4 id="（2）、函数表达式"><a href="#（2）、函数表达式" class="headerlink" title="（2）、函数表达式"></a>（2）、函数表达式</h4><p>除了用function命令声明函数，黑可以采用变量赋值的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print=<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部有效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print=<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//ERROR</span></span><br><span class="line">print();<span class="comment">//function</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。    </p>
<h4 id="（3）、Function构造函数"><a href="#（3）、Function构造函数" class="headerlink" title="（3）、Function构造函数"></a>（3）、Function构造函数</h4><p>第三种方式是使用Function构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。</p>
</blockquote>
<p>你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return "hello world"'</span>);</span><br></pre></td></tr></table></figure>
<p>Function构造函数可以不使用new命名，返回结果完全一样。总的来说，这种声明函数的方式非常不直观，几乎无人使用。   </p>
<h3 id="2-函数的重复声明"><a href="#2-函数的重复声明" class="headerlink" title="2. 函数的重复声明"></a>2. 函数的重复声明</h3><p>如果同一个函数被多次声明，后面的声明会覆盖前面的声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，后一次的函数声明覆盖了前一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这点要特别注意。   </p>
<h3 id="3-圆括号运算符，return语句和递归"><a href="#3-圆括号运算符，return语句和递归" class="headerlink" title="3. 圆括号运算符，return语句和递归"></a>3. 圆括号运算符，return语句和递归</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>函数体内部的return语句，表示返回。javascript引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。   </p>
<p>函数可以调用自身，这就是递归。下面就是通过递归，计算斐波那契数列的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(num<span class="number">-2</span>)+fib(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>);<span class="comment">//8</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。</p>
</blockquote>
<h3 id="4-第一等公民"><a href="#4-第一等公民" class="headerlink" title="4.第一等公民"></a>4.第一等公民</h3><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。   </p>
<p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> operator=add;</span><br><span class="line"><span class="comment">//将函数作为参数和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">op</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-函数名的提升"><a href="#5-函数名的提升" class="headerlink" title="5.函数名的提升"></a>5.函数名的提升</h3><p>javascript引擎将函数名视同变量名，所以function命名声明函数时，整个函数会先变量声明一样，被提升到代码头部。所以，下面的代码不会报错。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，javascript就会报错。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码等同于下面的形式   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f;</span><br><span class="line">f();</span><br><span class="line">f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。<br>因此，如果同时采用function命名和赋值语句声明同一个函数，最后总是采用赋值语句的定义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-不能在条件语句中声明函数"><a href="#6-不能在条件语句中声明函数" class="headerlink" title="6.不能在条件语句中声明函数"></a>6.不能在条件语句中声明函数</h3><p>根据ES5的规范，不得在非函数的代码中声明函数，最常见的情况就是if和try语句。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码分别在if代码块和try代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。<br>上面代码分别在if代码块和try代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。<br>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> f();<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure>
<p> 上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、函数的属性和方法"><a href="#二、函数的属性和方法" class="headerlink" title="二、函数的属性和方法"></a>二、函数的属性和方法</h2><h3 id="1-name属性"><a href="#1-name属性" class="headerlink" title="1.name属性"></a>1.name属性</h3><p>函数的name属性返回紧跟在function关键字之后的那个函数名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1.name);<span class="comment">//'f1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(f2.name);<span class="comment">//''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3=<span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(f3.name);<span class="comment">//'myName'</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数的name属性总是返回紧跟在function关键字之后的那个函数名。对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。    </p>
<h3 id="2-length属性"><a href="#2-length属性" class="headerlink" title="2.length属性"></a>2.length属性</h3><p>函数的length属性返回函数 <strong>预期</strong> 传入的参数个数，即函数定义之中的参数个数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输出入了多少个参数，length属性始终等于2。<br>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”(overload)。    </p>
<h3 id="3-toString"><a href="#3-toString" class="headerlink" title="3.toString()"></a>3.toString()</h3><p>函数的toString方法返回一个字符串，内容是函数的源码。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a();</span><br><span class="line">    b();</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString();</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>函数内部的注释也可以返回。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// "function f()&#123;/*</span></span><br><span class="line"><span class="comment">//   这是一个</span></span><br><span class="line"><span class="comment">//   多行注释</span></span><br><span class="line"><span class="comment">// */&#125;"</span></span><br></pre></td></tr></table></figure>
<p>利用这一点，可以变相实现多行字符串。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline =<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr=fn.toString().split(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.slice(<span class="number">1</span>,arr.length<span class="number">-1</span>).join(<span class="string">'\n'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line">multiline(f);</span><br><span class="line"><span class="comment">// " 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释"</span></span><br></pre></td></tr></table></figure>
<h2 id="三、函数作用域"><a href="#三、函数作用域" class="headerlink" title="三、函数作用域"></a>三、函数作用域</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>作用域（scope）指的是变量存在的范围。在ES5的规范中，javascript只有两种作用域：一种是全局作用域，变量在整个过程中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6新增了块级作用域。    </p>
<p>函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-函数内部的变量提升"><a href="#2-函数内部的变量提升" class="headerlink" title="2.函数内部的变量提升"></a>2.函数内部的变量提升</h3><p>与全局作用一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp=x<span class="number">-100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">100</span>)&#123;</span><br><span class="line">        tmp=x<span class="number">-100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-函数本身的作用域"><a href="#3-函数本身的作用域" class="headerlink" title="3.函数本身的作用域"></a>3.函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其他运行时所在的作用域无关。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数x是在函数f外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。<br>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。<br>很容易犯错的一点是，如果函数A调用函数B，却没有考虑到函数B不会引用函数A的内部变量。<br>很容易犯错的一点是，如果函数A调用函数B，却没有考虑到函数B不会引用函数A的内部变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">y(x);</span><br><span class="line"><span class="comment">//ReferenceError:a is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。   </p>
<p>同样的，函数内部声明的函数，作用域绑定函数体内部。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f=foo();</span><br><span class="line">f();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成“闭包”现象。    </p>
<h2 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line">square(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">square(<span class="number">3</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></p>
<p>上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。   </p>
<h3 id="2-参数的省略"><a href="#2-参数的省略" class="headerlink" title="2.参数的省略"></a>2.参数的省略</h3><p>函数的参数不是必须所谓，javascript允许省略参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">f(<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">f();<span class="comment">//undefined</span></span><br><span class="line">f.length;<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。    </p>
<p>但是，没有办法只能省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(,<span class="number">1</span>);<span class="comment">//SyntaxError: Unexpected token ,(…)</span></span><br><span class="line">f(<span class="literal">undefined</span>,<span class="number">1</span>);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果省略第一个参数，就会报错。   </p>
<h3 id="3-传递方式"><a href="#3-传递方式" class="headerlink" title="3.传递方式"></a>3.传递方式</h3><p>函数参数如果是原始类型的值（数值，字符串，布尔值），传递方式是传值传递（pass by value）。这意味着，在函数体内修改参数数值，不会影响到函数外部。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">  p=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"><span class="built_in">console</span>.log(p);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。<br>但是，如果函数参数是复合类型的值（数组，对象，其他函数），传递方式是传址传值（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">p</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    o.p=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.p);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。   </p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  o=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数(o)的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。    </p>
<h3 id="4-同名参数"><a href="#4-同名参数" class="headerlink" title="4.同名参数"></a>4.同名参数</h3><p>如果有同名参数，则取最后 出现的那个值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h3 id="5-arguments对象"><a href="#5-arguments对象" class="headerlink" title="5.arguments对象"></a>5.arguments对象</h3><h4 id="（1）、定义"><a href="#（1）、定义" class="headerlink" title="（1）、定义"></a>（1）、定义</h4><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。   </p>
<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">one</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>正常模式下，arguments对象可以在运行时修改。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。<br>严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;<span class="comment">//开启严格模式</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>; <span class="comment">// 无效</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 无效</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。<br>通过arguments对象的length属性，可以判断函数调用时到底带几个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="（2）、与数组的关系"><a href="#（2）、与数组的关系" class="headerlink" title="（2）、与数组的关系"></a>（2）、与数组的关系</h4><p>需要注意的是，虽然arguments很像数组，但它是一个对象（其实它是一个类数组）。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。<br>如果让arguments对象使用数组方法，真正解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> args=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="（3）、callee属性"><a href="#（3）、callee属性" class="headerlink" title="（3）、callee属性"></a>（3）、callee属性</h4><p>arguments对象带有一个callee属性，返回它所对应的原函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee===f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过arguments.callee，达到函数调用自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。   </p>
<hr>
<h1 id="ES6中关于函数的扩增"><a href="#ES6中关于函数的扩增" class="headerlink" title="ES6中关于函数的扩增"></a>ES6中关于函数的扩增</h1><p>ES6中函数的扩展主要是 <strong>箭头函数</strong> 的使用。下面介绍的内容如下：   </p>
<ol>
<li>函数参数的默认值</li>
<li>rest参数</li>
<li>严格模式</li>
<li>name属性</li>
<li>箭头函数</li>
<li>双冒号运算符</li>
</ol>
<h2 id="一、函数参数的默认值"><a href="#一、函数参数的默认值" class="headerlink" title="一、函数参数的默认值"></a>一、函数参数的默认值</h2><p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  y=y||<span class="string">'world'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'hello'</span>);<span class="comment">//hello world</span></span><br><span class="line">log(<span class="string">'hello'</span>,<span class="string">'china'</span>);<span class="comment">//hello china</span></span><br><span class="line">log(<span class="string">'hello'</span>,<span class="string">''</span>);<span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<p>上面代码检查log的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值是false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。<br>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值，于是做了下面的改进。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> y===<span class="string">'undefined'</span>)&#123;</span><br><span class="line">  y=<span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6允许为函数的参数设置默认值，即直接写在参数参数定义的后面</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y=<span class="string">'world'</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'hello'</span>);<span class="comment">//hello world</span></span><br><span class="line">log(<span class="string">'hello'</span>,<span class="string">'chain'</span>);<span class="comment">//hello chain</span></span><br><span class="line">log(<span class="string">'hello'</span>,<span class="string">''</span>);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure></p>
<p>==注意==：参数变量是默认声明的，所以不能用let或const再次声明。否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x=<span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line">  <span class="keyword">const</span> x=<span class="number">2</span>;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用参数默认值时，函数不能有同名参数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,x,y</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,x,y=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，一个容易忽略的地方就是，参数默认值是不传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p=x+<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//100</span></span><br><span class="line">x=<span class="number">100</span>;</span><br><span class="line">foo();<span class="comment">//101</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数p的默认值是x+1。这时，每次调用函数foo(),都会重新计算x+1，而不是默认p等于100。    </p>
<p>###　1. 与解构赋值结合使用<br>参数默认值可以与解构赋值的默认值，结合起来使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y=<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;&#125;);<span class="comment">//undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);<span class="comment">//1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;);<span class="comment">//1 2</span></span><br><span class="line">foo();<span class="comment">//TypeError:Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没有提供参数，变量x和y就不会生成，从而报错。通过提供函数参数默认值，就可以避免这种情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x,y=<span class="number">5</span>&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//undefined 5</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码指定，如果没有提供参数，函数foo的参数默认值就是一个空对象。<br>下面是另一个解构赋值默认值的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url,&#123;body=<span class="string">''</span>,method=<span class="string">'GET'</span>,headers=&#123;&#125;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>,&#123;&#125;)</span><br><span class="line"><span class="comment">//GET</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为他的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url,&#123;body=<span class="string">''</span>,method=<span class="string">'GET'</span>,headers=&#123;&#125;&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">'hrrp://example.com'</span>);</span><br></pre></td></tr></table></figure></p>
<p>作为练习，请问下面两种写法有什么差别？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x=<span class="number">0</span>,y=<span class="number">0</span>&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x,y&#125;=&#123;x:<span class="number">0</span>,y:<span class="number">0</span>&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象的解构赋值的默认值；写法二函数参数的默认值是一个具体属性的对象，但是没有设置对象解构赋值的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数没有参数</span></span><br><span class="line">m1();<span class="comment">//0 0</span></span><br><span class="line">m2();<span class="comment">//0 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x和y都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">8</span>&#125;);<span class="comment">//3 8</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">8</span>&#125;);<span class="comment">//3 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x有值，y无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;);<span class="comment">//3 0</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;);<span class="comment">//3 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x和y都无值的情况</span></span><br><span class="line">m1(&#123;&#125;);<span class="comment">//0 0</span></span><br><span class="line">m2(&#123;&#125;);<span class="comment">//undefined undefined</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;);<span class="comment">//0 0</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;);<span class="comment">//undefined undefined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-函数默认值的位置"><a href="#2-函数默认值的位置" class="headerlink" title="2.函数默认值的位置"></a>2.函数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。 如果非尾参数设置默认值，实际上这个参数是没法省略的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x=<span class="number">1</span>,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x,y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();<span class="comment">//[1,undefined]</span></span><br><span class="line">f(<span class="number">2</span>);<span class="comment">//[2,undefined]</span></span><br><span class="line">f(,<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">f(<span class="literal">undefined</span>,<span class="number">1</span>);<span class="comment">//[1,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y=<span class="number">5</span>,z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>[x,y,z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();<span class="comment">//[undefined,5,undefined];</span></span><br><span class="line">f(<span class="number">1</span>);<span class="comment">//[1,5,undefined]</span></span><br><span class="line">f(<span class="number">1</span>,,<span class="number">2</span>);<span class="comment">//报错</span></span><br><span class="line">f(<span class="number">1</span>,<span class="literal">undefined</span>,<span class="number">2</span>);<span class="comment">//[1,5,2]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，有默认值的参数都不是尾参数，这时，无法省略参数，而不省略后面的参数，除非显示输入undefined。<br>如果传入undefined，将触发参数等于默认值，null则没有这个效果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">5</span>,y=<span class="number">6</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>,<span class="literal">null</span>)</span><br><span class="line"><span class="comment">//5 null</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。    </p>
<h3 id="3-函数的length属性"><a href="#3-函数的length属性" class="headerlink" title="3.函数的length属性"></a>3.函数的length属性</h3><p>指定默认值后，函数length属性，将返回没有指定默认值的参数个数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;&#125;).length;<span class="comment">//1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">5</span></span>)</span>&#123;&#125;).length<span class="comment">//0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=<span class="number">5</span></span>)</span>&#123;&#125;).length<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的rest参数也不会计入length属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;&#125;).length;<span class="comment">//0</span></span><br></pre></td></tr></table></figure></p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">0</span>,b,c</span>)</span>&#123;&#125;).length<span class="comment">//0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b=<span class="number">1</span>,c</span>)</span>&#123;&#125;).length<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y=x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，参数y的默认值等于变量x，调用函数f时，参数形成一个单独的作用域，在这个作用域里面，默认值变量x指向第一个参数，而不是全局变量x，所以输出2。<br>再看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y=x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，函数f调用时，参数y=x形成一个单独的作用域。在这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内的局部变量x影响不到默认值变量x。<br>如果此时，全局变量x不存在，就会报错。<br>下面这些写也会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=x</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">////ReferenceError:x is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，参数x=x形成一个单独作用域。实际执行的是let x=x,由于暂时性死区的原因，这行代码会报错”X未定义”。     </p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵循这个规则：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo=<span class="string">'outer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func=(</span>)=&gt;<span class="title">foo</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo=<span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//outer</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层全局变量foo，因此输出outer。    </p>
<p>如果写成下面这样，就会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func=(</span>)=&gt;<span class="title">foo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo=<span class="string">'innner'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//ReferenceError:foo is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>下面更复杂的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y=function(</span>)</span>&#123;x=<span class="number">2</span>&#125;)&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，函数foo的参数形成了一个单独的作用域。这个作用域里面首先声明了变量x，然后是y,y的默认值是一个匿名函数。这个匿名函数内部变量x，指向同一个作用域下的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，素以不是同一个变量，因此执行y后，内部变量x和外部变量x的值不变。<br>如果将var x=3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层全局x依然不受影响。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y=function(</span>)</span>&#123;x=<span class="number">2</span>&#125;)&#123;</span><br><span class="line">  x=<span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-应用"><a href="#5-应用" class="headerlink" title="5. 应用"></a>5. 应用</h3><p>利用参数默认值，可以指定某个参数不得省略，如果省略就抛出一个错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided=throwIfMissing(</span>))</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//Error：Missing parameter</span></span><br></pre></td></tr></table></figure></p>
<p>另外也可以将参数设置为undefined，表明这个参数是可以省略的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional=undefined</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、rest参数"><a href="#二、rest参数" class="headerlink" title="二、rest参数"></a>二、rest参数</h2><p>ES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> values)&#123;</span><br><span class="line">        sum+=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></p>
<p>下面是一个rest参数代替arguments变量的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers=<span class="function">(<span class="params">...numbers</span>)=&gt;</span>numbers.sort();</span><br></pre></td></tr></table></figure></p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest参数就不存在这个问题，它就是一个真正数组，数组的特有方法它都可以使用。<br>下面是一个利用rest参数改写数组push方法的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array,...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line">push(a,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>==注意==：rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,...b,c</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>函数的length属性，不包括rest参数</strong>    </p>
<h2 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h2><p>从ES5开始，函数内部可以设定为严格模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES2016做了一点修改，规定值要函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b=a</span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func=<span class="function"><span class="keyword">function</span>(<span class="params">&#123;a,b&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="string">'user strict'</span>;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">const</span> func=<span class="function">(<span class="params">...a</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后在执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">value=<span class="number">070</span></span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，参数value的默认值是八进制数070，但是在严格模式下不能用前缀0表示八进制，所以应该报错。但实际上，javascript引擎会先成功执行value=070,然后进入函数体内部，发现需要严格模式执行，这时才会报错。<br>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性，因此，标准索性禁止了这种用法，只要参数使用了默认值，解构赋值，或者扩展运算符，就不显式指定严格模式。<br>两种方法可以规避这种限制，第一种是设置全局的严格模式，这是合法的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b=a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是把函数包在一个无参数的立即执行的函数里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value=<span class="number">42</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h2 id="四、name属性"><a href="#四、name属性" class="headerlink" title="四、name属性"></a>四、name属性</h2><p>上面有说到函数的name属性。<br>函数的name属性，返回该函数的函数名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.name<span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure></p>
<p>略。。。   </p>
<h2 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h3><p>ES6允许使用“箭头”定义函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="params">v</span>=&gt;</span>v;</span><br></pre></td></tr></table></figure></p>
<p>等同于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="params">()</span>=&gt;</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum=<span class="function">(<span class="params">num1,num2</span>)=&gt;</span>num1+num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果箭头函数的代码块部分多余一条语句，就要使用大括号将它们括起来，并且使用return语句返回</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function">(<span class="params">num1,num2</span>)=&gt;</span>&#123;<span class="keyword">return</span> num1+num2&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem=<span class="function"><span class="params">id</span>=&gt;</span>&#123;<span class="attr">id</span>:id,<span class="attr">name</span>:<span class="string">'Temp'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getTempItem=<span class="function"><span class="params">id</span>=&gt;</span>(&#123;<span class="attr">id</span>:id,<span class="attr">name</span>:<span class="string">'Temp'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn=<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure></p>
<p><strong>箭头函数可以与变量解构结合使用</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full=<span class="function">(<span class="params">&#123;first,last&#125;</span>)=&gt;</span>first+<span class="string">' '</span>+last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first+<span class="string">' '</span>+person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数使用的表达式更加简洁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven=<span class="function"><span class="params">n</span>=&gt;</span>n%<span class="number">2</span>===<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square=<span class="function"><span class="params">n</span>=&gt;</span>n*n;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。<br><strong>箭头函数的一个用处是简化回调函数。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span>=&gt;</span>x*x);</span><br></pre></td></tr></table></figure></p>
<p>另外一个例子是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result=values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result=values.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br></pre></td></tr></table></figure></p>
<p><strong>下面是rest参数与箭头函数结合的例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers=<span class="function">(<span class="params">...nums</span>)=&gt;</span>nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail=<span class="function">(<span class="params">head,...tail</span>)=&gt;</span>[head,tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-使用注意点"><a href="#1-使用注意点" class="headerlink" title="1.使用注意点"></a>1.使用注意点</h3><p>箭头函数有几个注意点   </p>
<ol>
<li>函数体内this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用res参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ol>
<p>上面四点中，第一点尤其值得注意，this对象的指向是可变的，但是在箭头函数中，它是固定的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id'</span>,<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> id=<span class="number">21</span>;</span><br><span class="line">foo.call(&#123;<span class="attr">id</span>:<span class="number">42</span>&#125;);</span><br><span class="line"><span class="comment">//id:42</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒之后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21，但是，箭头函数导致this总是指向函数定义生效时所对应的对象（本例是{id:42}）,所以输出的是42。<br>如果是普通函数，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>,<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id=<span class="number">21</span>;</span><br><span class="line">foo.call(&#123;<span class="attr">id</span>:<span class="number">42</span>&#125;);</span><br><span class="line"><span class="comment">//id:21</span></span><br></pre></td></tr></table></figure></p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s2=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//箭头函数</span></span><br><span class="line">    setInterval=<span class="function">(<span class="params">(</span>)=&gt;</span><span class="keyword">this</span>.s1++,<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.s2++;</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer=<span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'s1:'</span>,timer.s1),<span class="number">3100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'s2:'</span>,timer.s2),<span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1:3</span></span><br><span class="line"><span class="comment">// s2:0</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数前者的this绑定了定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没有更新。<br><strong>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler=&#123;</span><br><span class="line">  id:<span class="string">'123456'</span>,</span><br><span class="line">  init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,event=&gt;<span class="keyword">this</span>.doSomething(event.type),<span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething:<span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Handling'</span>+type+<span class="string">'for'</span>+<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。<br>his指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。<br>所以，箭头函数转成ES5的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id'</span>,<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that=<span class="keyword">this</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id'</span>,that.id);</span><br><span class="line">  &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，转换成ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。<br>请问下面的代码之中有几个this？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>,<span class="keyword">this</span>.id)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f=foo.call(&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> t1=f.call(&#123;<span class="attr">id</span>:<span class="number">2</span>&#125;)()();<span class="comment">//id:1</span></span><br><span class="line"><span class="keyword">var</span> t2=f().call(&#123;<span class="attr">id</span>:<span class="number">3</span>&#125;)();<span class="comment">//id:1</span></span><br><span class="line"><span class="keyword">var</span> t3=f()().call(&#123;<span class="attr">id</span>:<span class="number">4</span>&#125;);<span class="comment">//id:1</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码之中，只有一个this，就是函数foo的this，所以t1，t2,t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。    </p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments,super,new.target。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'args:'</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//args:[2,3,4,6]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，箭头函数内部变量arguments，其实是函数foo的arguments变量。<br>另外，由于箭头函数没有自己的this，所以当然就不能用call()、apply()、bind()这些方法去改变this的指向。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        (<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.x).bind(&#123;<span class="attr">x</span>:<span class="string">'inner'</span>&#125;)()</span><br><span class="line">    ];</span><br><span class="line">&#125;).call(&#123;<span class="attr">x</span>:<span class="string">'outer'</span>&#125;);</span><br><span class="line"><span class="comment">//['outer']</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。    </p>
<h3 id="2-嵌套的箭头函数"><a href="#2-嵌套的箭头函数" class="headerlink" title="2. 嵌套的箭头函数"></a>2. 嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">into</span>:<span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">after</span>:<span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>)</span>&#123;</span><br><span class="line">            array.splice(arry.indexOf(afterValue)+<span class="number">1</span>,<span class="number">0</span>,value);</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>,<span class="number">3</span>]).after(<span class="number">1</span>);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<p>上面这个函数，可以使用箭头函数改写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> insert=<span class="function">(<span class="params">value</span>)=&gt;</span><span class="function">(<span class="params">&#123;into:(array</span>)=&gt;</span><span class="function">(<span class="params">&#123;after:(afterValue</span>)=&gt;</span>&#123;</span><br><span class="line">    array.splice(array.indexOf(afterValue)+<span class="number">1</span>,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>,<span class="number">3</span>]).after(<span class="number">1</span>);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<p>下面是一个部署管道机制(pipeline)的例子，即前一个函数的输出是后一个函数的输入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline=<span class="function">(<span class="params">...funcs</span>)=&gt;</span></span><br><span class="line">val=&gt;func.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b(a),val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1=<span class="function"><span class="params">a</span>=&gt;</span>a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2=<span class="function"><span class="params">a</span>=&gt;</span>a*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addTheMult=pipeline(plus,mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure></p>
<p><strong>箭头函数还有一个功能，就是可以很方便地改写λ演算</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//λ演算的写法</span></span><br><span class="line">fix=λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> fix=<span class="function"><span class="params">f</span>=&gt;</span>(<span class="function"><span class="params">x</span>=&gt;</span>f(<span class="function"><span class="params">v</span>=&gt;</span>x(x)(v)))</span><br><span class="line">(<span class="function"><span class="params">x</span>=&gt;</span>f(<span class="function"><span class="params">v</span>=&gt;</span>x(x)(v)));</span><br></pre></td></tr></table></figure></p>
<p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。    </p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.png" alt="稻香Snowy wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="稻香Snowy 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript初探/" rel="tag"><i class="fa fa-tag"></i> JavaScript初探</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/JavaScript/JS初探八（JS中的字符串）/" rel="next" title="JS初探八（JS中的字符串）">
                <i class="fa fa-chevron-left"></i> JS初探八（JS中的字符串）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/JavaScript/JS初探十（JS中的内置对象）/" rel="prev" title="JS初探十（JS的内置对象）">
                JS初探十（JS的内置对象） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/toux.jpg"
                alt="稻香Snowy" />
            
              <p class="site-author-name" itemprop="name">稻香Snowy</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry.Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Asiazdx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/fb5f478b1a94" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/59638598f265da6c4523c761" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-spinner"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5541828133/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-Weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-number">1.</span> <span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-函数的声明"><span class="nav-number">1.1.</span> <span class="nav-text">1.函数的声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）、function命令"><span class="nav-number">1.1.1.</span> <span class="nav-text">（1）、function命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）、函数表达式"><span class="nav-number">1.1.2.</span> <span class="nav-text">（2）、函数表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）、Function构造函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">（3）、Function构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数的重复声明"><span class="nav-number">1.2.</span> <span class="nav-text">2. 函数的重复声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-圆括号运算符，return语句和递归"><span class="nav-number">1.3.</span> <span class="nav-text">3. 圆括号运算符，return语句和递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-第一等公民"><span class="nav-number">1.4.</span> <span class="nav-text">4.第一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-函数名的提升"><span class="nav-number">1.5.</span> <span class="nav-text">5.函数名的提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-不能在条件语句中声明函数"><span class="nav-number">1.6.</span> <span class="nav-text">6.不能在条件语句中声明函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、函数的属性和方法"><span class="nav-number">2.</span> <span class="nav-text">二、函数的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-name属性"><span class="nav-number">2.1.</span> <span class="nav-text">1.name属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-length属性"><span class="nav-number">2.2.</span> <span class="nav-text">2.length属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-toString"><span class="nav-number">2.3.</span> <span class="nav-text">3.toString()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、函数作用域"><span class="nav-number">3.</span> <span class="nav-text">三、函数作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-定义"><span class="nav-number">3.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数内部的变量提升"><span class="nav-number">3.2.</span> <span class="nav-text">2.函数内部的变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-函数本身的作用域"><span class="nav-number">3.3.</span> <span class="nav-text">3.函数本身的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、参数"><span class="nav-number">4.</span> <span class="nav-text">四、参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述"><span class="nav-number">4.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-参数的省略"><span class="nav-number">4.2.</span> <span class="nav-text">2.参数的省略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-传递方式"><span class="nav-number">4.3.</span> <span class="nav-text">3.传递方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-同名参数"><span class="nav-number">4.4.</span> <span class="nav-text">4.同名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-arguments对象"><span class="nav-number">4.5.</span> <span class="nav-text">5.arguments对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）、定义"><span class="nav-number">4.5.1.</span> <span class="nav-text">（1）、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）、与数组的关系"><span class="nav-number">4.5.2.</span> <span class="nav-text">（2）、与数组的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）、callee属性"><span class="nav-number">4.5.3.</span> <span class="nav-text">（3）、callee属性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6中关于函数的扩增"><span class="nav-number"></span> <span class="nav-text">ES6中关于函数的扩增</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、函数参数的默认值"><span class="nav-number">1.</span> <span class="nav-text">一、函数参数的默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数默认值的位置"><span class="nav-number">1.1.</span> <span class="nav-text">2.函数默认值的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-函数的length属性"><span class="nav-number">1.2.</span> <span class="nav-text">3.函数的length属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-作用域"><span class="nav-number">1.3.</span> <span class="nav-text">4.作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-应用"><span class="nav-number">1.4.</span> <span class="nav-text">5. 应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、rest参数"><span class="nav-number">2.</span> <span class="nav-text">二、rest参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、严格模式"><span class="nav-number">3.</span> <span class="nav-text">三、严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、name属性"><span class="nav-number">4.</span> <span class="nav-text">四、name属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、箭头函数"><span class="nav-number">5.</span> <span class="nav-text">五、箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基本用法"><span class="nav-number">5.1.</span> <span class="nav-text">1.基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用注意点"><span class="nav-number">5.2.</span> <span class="nav-text">1.使用注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-嵌套的箭头函数"><span class="nav-number">5.3.</span> <span class="nav-text">2. 嵌套的箭头函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">稻香Snowy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
</body>

<script>
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var cw = canvas.width = window.innerWidth,
  cx = cw / 2;
var ch = canvas.height = window.innerHeight,
  cy = ch / 2;

ctx.fillStyle = "#999";
var linesNum = 16;
var linesRy = [];
var requestId = null;

function Line(flag) {
  this.flag = flag;
  this.a = {};
  this.b = {};
  if (flag == "v") {
    this.a.y = 0;
    this.b.y = ch;
    this.a.x = randomIntFromInterval(0, ch);
    this.b.x = randomIntFromInterval(0, ch);
  } else if (flag == "h") {
    this.a.x = 0;
    this.b.x = cw;
    this.a.y = randomIntFromInterval(0, cw);
    this.b.y = randomIntFromInterval(0, cw);
  }
  this.va = randomIntFromInterval(25, 100) / 100;
  this.vb = randomIntFromInterval(25, 100) / 100;

  this.draw = function() {
    ctx.strokeStyle = "#ccc";
    ctx.beginPath();
    ctx.moveTo(this.a.x, this.a.y);
    ctx.lineTo(this.b.x, this.b.y);
    ctx.stroke();
  }

  this.update = function() {
    if (this.flag == "v") {
      this.a.x += this.va;
      this.b.x += this.vb;
    } else if (flag == "h") {
      this.a.y += this.va;
      this.b.y += this.vb;
    }

    this.edges();
  }

  this.edges = function() {
    if (this.flag == "v") {
      if (this.a.x < 0 || this.a.x > cw) {
        this.va *= -1;
      }
      if (this.b.x < 0 || this.b.x > cw) {
        this.vb *= -1;
      }
    } else if (flag == "h") {
      if (this.a.y < 0 || this.a.y > ch) {
        this.va *= -1;
      }
      if (this.b.y < 0 || this.b.y > ch) {
        this.vb *= -1;
      }
    }
  }

}

for (var i = 0; i < linesNum; i++) {
  var flag = i % 2 == 0 ? "h" : "v";
  var l = new Line(flag);
  linesRy.push(l);
}

function Draw() {
  requestId = window.requestAnimationFrame(Draw);
  ctx.clearRect(0, 0, cw, ch);

  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    l.draw();
    l.update();
  }
  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    for (var j = i + 1; j < linesRy.length; j++) {
      var l1 = linesRy[j]
      Intersect2lines(l, l1);
    }
  }
}

function Init() {
  linesRy.length = 0;
  for (var i = 0; i < linesNum; i++) {
    var flag = i % 2 == 0 ? "h" : "v";
    var l = new Line(flag);
    linesRy.push(l);
  }

  if (requestId) {
    window.cancelAnimationFrame(requestId);
    requestId = null;
  }

  cw = canvas.width = window.innerWidth,
    cx = cw / 2;
  ch = canvas.height = window.innerHeight,
    cy = ch / 2;

  Draw();
};

setTimeout(function() {
  Init();

  addEventListener('resize', Init, false);
}, 15);

function Intersect2lines(l1, l2) {
  var p1 = l1.a,
    p2 = l1.b,
    p3 = l2.a,
    p4 = l2.b;
  var denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
  var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
  var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
  var x = p1.x + ua * (p2.x - p1.x);
  var y = p1.y + ua * (p2.y - p1.y);
  if (ua > 0 && ub > 0) {
    markPoint({
      x: x,
      y: y
    })
  }
}

function markPoint(p) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
  ctx.fill();
}

function randomIntFromInterval(mn, mx) {
  return ~~(Math.random() * (mx - mn + 1) + mn);
}

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</script>
</html>
