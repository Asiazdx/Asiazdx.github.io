<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #AFDBE3; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #AFDBE3, 0 0 5px     #AFDBE3; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #AFDBE3;    /*上边框颜色*/
        border-left-color: #AFDBE3;    /*左边框颜色*/
    }
</style>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript进阶," />










<meta name="description" content="DOM（文档对象模型）是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加，移除和修改页面的某一部分。">
<meta name="keywords" content="JavaScript进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="JS进阶一（JS中的DOM）">
<meta property="og:url" content="http://www.github.com/Snowyzdx/JavaScript/JS进阶一（JS中的DOM）/index.html">
<meta property="og:site_name" content="Snowy&#39;blog">
<meta property="og:description" content="DOM（文档对象模型）是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加，移除和修改页面的某一部分。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/jsJichujsb01.png">
<meta property="og:updated_time" content="2018-05-08T02:14:53.212Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS进阶一（JS中的DOM）">
<meta name="twitter:description" content="DOM（文档对象模型）是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加，移除和修改页面的某一部分。">
<meta name="twitter:image" content="http://p6nfblqvu.bkt.clouddn.com/jsJichujsb01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="http://www.github.com/Snowyzdx/JavaScript/JS进阶一（JS中的DOM）/"/>





  <title>JS进阶一（JS中的DOM） | Snowy'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Asiazdx"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Snowy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Stay Hungry. Stay Foolish</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-comments">
          <a href="/comments/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heart"></i> <br />
            
            留言板
          </a>
        </li>
      
        
        <li class="menu-item menu-item-laboratory">
          <a href="/laboratory/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />
            
            实验室
          </a>
        </li>
      
        
        <li class="menu-item menu-item-other_note">
          <a href="/other_note/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书影音
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.github.com/Snowyzdx/JavaScript/JS进阶一（JS中的DOM）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="稻香Snowy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Snowy'blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JS进阶一（JS中的DOM）</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-20T09:51:45+08:00">
                2016-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://p6nfblqvu.bkt.clouddn.com/jsJichujsb01.png" width="600" alt="jsb01"><br>DOM（文档对象模型）是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加，移除和修改页面的某一部分。<br><a id="more"></a></p>
<h1 id="JS中的DOM（一）"><a href="#JS中的DOM（一）" class="headerlink" title="JS中的DOM（一）"></a>JS中的DOM（一）</h1><h2 id="一、节点层次"><a href="#一、节点层次" class="headerlink" title="一、节点层次"></a>一、节点层次</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每一种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记表现为一个一特定节点为根节点的树形结构。一个简单的文档结构如下：    </p>
<blockquote>
<p>DOcument——&gt;Element html——&gt;Element head ——&gt;Element title——&gt;Text Sample page<br>Document——&gt;Element html ——&gt;Element head ——&gt;Element body——&gt;Element p——&gt;Text (hello world)</p>
</blockquote>
<p>在这个例子中，文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。   </p>
<p>一段元素都可以通过树中一个节点来表示：HTML元素通过元素节点来表示，特性（attribute）通过特性来表示，文档类型通过文档类型节点来表示，而注释则通过注释节点来表示。总共有12种节点类型，这些类型都继承自一个基类型。   </p>
<h2 id="二、Node类型"><a href="#二、Node类型" class="headerlink" title="二、Node类型"></a>二、Node类型</h2><p>DOM1级定义了一个Node接口，该接口将有DOM中所有的节点类型实现。这个Node接口在Javascript中是作为Node类型实现的；除了IE之外，在其他所有的浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：   </p>
<ul>
<li>Node.ELEMENT_NODE(1)</li>
<li>Node.ATTRIBUTE_NODE(2)</li>
<li>Node.TEXT_NODE(3)</li>
<li>Node.CDATA_SECTION_NODE(4)</li>
<li>Node.ENTITY_REFERENCE_NODE(5)</li>
<li>Node.ENTITY_NODE(6)</li>
<li>Node.PROCESSING_INSTRUCTION_NODE(7)</li>
<li>Node.COMMENT_NODE(8)</li>
<li>Node.DOCUMENT_NODE(9)</li>
<li>Node.DOCUMENT_TYPE_NODE(10)</li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11)</li>
<li>Node.NOTATION_NODE(12)</li>
</ul>
<p>通过比较上面的这些常量，可以很容易地确定节点的类型，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType===Node.ELEMENT_NODE)&#123;<span class="comment">//IE浏览器不支持</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'node is an element'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子中比较了someNode.nodeType与Node.ELEMENT_NODE常量。如果二者相等，则意味着someNode确实是一个元素。然而，由于IE没有公共Node类型的构造函数，因此上面的代码在IE中会导致错误。为了确保跨域浏览器兼容，最好还是将nodetype属性与数值进行比较，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType==<span class="number">1</span>)&#123;<span class="comment">//适用于所有浏览器</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Node is element'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并不是所有的节点类型都受到Web浏览器的支持。开发人员最常用的就是元素和文本节点。   </p>
<h2 id="二、Node属性概述"><a href="#二、Node属性概述" class="headerlink" title="二、Node属性概述"></a>二、Node属性概述</h2><p>Node常用属性主要有以下10个，接下来我们会着重讲解部分属性。   </p>
<ul>
<li>nodeType：显示节点的类型</li>
<li>nodeName：显示节点的姓名</li>
<li>nodeValue：显示节点的值</li>
<li>attribute：获取一个属性节点</li>
<li>firstChild：表示某一节点的第一个子节点</li>
<li>lastChild:表示一个节点的最后一个子节点</li>
<li>childNodes：表示所在节点的所有子节点</li>
<li>parentNode：表示所在节点的父节点</li>
<li>nextSibling：紧挨着当前节点的下一个节点</li>
<li>previousSibling：紧挨着当前节点的上一个节点</li>
</ul>
<h3 id="1-nodeName和nodeValue属性"><a href="#1-nodeName和nodeValue属性" class="headerlink" title="1.nodeName和nodeValue属性"></a>1.nodeName和nodeValue属性</h3><p>要了解节点的就具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType==<span class="number">1</span>)&#123;</span><br><span class="line">    value=someNode.nodeName;<span class="comment">//nodeName的值是元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，首先检查节点的类型，看它是不是一个元素。如果是，则取得并保存nodeName的值。对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值则始终为null。    </p>
<h2 id="三、节点关系"><a href="#三、节点关系" class="headerlink" title="三、节点关系"></a>三、节点关系</h2><p>文档中所有节点之间都存在这样后者那样的关系。节点之间的各种关系可以用传统的家族关系来描述，相当于把文档比喻成家谱。<br>每个节点都有一个childNode属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。<br>下面的例子展示了如何访问保存在NodeList中的节点——可以通过方括号，也可以通过item()方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild=someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild=someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> count=someNode.childNodes.length;</span><br></pre></td></tr></table></figure></p>
<p>无论使用方括号还是item()方法都没有问题，但使用方括号语法看起来与访问数组相似，因此颇受一些开发人员的青睐。另外，要注意length属性表示的是访问NodeList的那一刻，其中包含的节点数量。   </p>
<p>每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes系列中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在childNodes列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同以列表中的其他节点。列表中第一个节点的previousSibling属性值为null，而列表中最后一个节点的nextSibling属性同样也为null，如下面的例子所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nextSibling===<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'last node in the parent childNode list'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(someNode.previousSibling===<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first node in the parent childNodes list'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，如果列表中只有一个节点，那么该节点的nextSibling和previousSibling都为null。   </p>
<p>父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个最后一个节点。其中，someNode.firstChild的值始终等于someNode.childNodes[0],而someNode.lastChild的值始终等于someNode.childNodes[someNode.childNodes.length-1]。在只有一个子节点的情况下，firstChild和lastChild指向同一节点。如没有子节点，那么firstChild和lastChild的值均为null。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。    </p>
<p>另外hasChildNodes()也是一个非常有用的方法，这个方法在节点包含一个或多个子节点的情况下返回true；应该说，这是比查询childNodes列表的length属性更简单的方法。   </p>
<p>所有节点都有最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都不属于它的所有文档，任何节点都不同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯达到顶端，而是可以直接访问文档节点。   </p>
<h2 id="四、操作节点"><a href="#四、操作节点" class="headerlink" title="四、操作节点"></a>四、操作节点</h2><p>因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。其中，最常用的方法是 <strong>appendChild()</strong>，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点，父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点。来看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode=someNode.appendChild(newNode);</span><br><span class="line"><span class="built_in">console</span>.log(returnedNode==newNode);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(someNode.lastChild==newNode);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置移到新的位置。即使可以将DOM树看成是由一系列指针连接起来的，但任何DOM节点也不能同时出现在文档中的多个位置上，因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点，如下面所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//someNode有多个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode=someNode.appendChild(someNode.firstChild);</span><br><span class="line"><span class="built_in">console</span>.log(returnedNode==someNode.firstChild);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(returnedNode==someNode.lastChild);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要把节点放在childNodes列表中某个特定的位置，而不是放在末尾，那么可以使用 <strong>insertBefore()</strong> 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点hi变成参照节点的前一个同胞节点previousSibling,同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作，如下面的例子所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为最后一个子节点</span></span><br><span class="line">returnedNode=someNode.insertBefore(newNode,<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newNode==someNode.lastChild);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode=someNode.insertBefore(newNode,someNode.firstChild);</span><br><span class="line"><span class="built_in">console</span>.log(returnedNode==newNode);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(newNode==someNode.firstChild);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到最后一个子节点前面</span></span><br><span class="line">returnedNode=someNode.insertBefore(newNode,someNode.lastChild);</span><br><span class="line"><span class="built_in">console</span>.log(newNode==someNode.childNodes[someNode.childNodes.length<span class="number">-2</span>]);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>前面介绍的appendChild()和insertBefore()方法都直插入节点，不会移除节点。而下面要介绍的 <strong>replaceChild()</strong> 方法接受的两个参数是:要插入的节点和要替换的节点。要替换的几点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。来看下面的例子。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode=someNode.replaceChild(newNode,someNode.firstChild);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换掉最后的子节点</span></span><br><span class="line">returnedNode=someNode.replaceChild(newNode,someNode.lastChild);</span><br></pre></td></tr></table></figure>
<p>在使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点赋值过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。    </p>
<p>如果想移除而非替换节点，可以使用 <strong>remodeChild()</strong> 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值，如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerFirstChild=someNode.removeChild(someNode.firstChild);</span><br><span class="line"><span class="comment">//移除最后一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerLastChild=someNode.removeChild(someNode.lastChild);</span><br></pre></td></tr></table></figure></p>
<p>与使用replaceChild()方法一样，通过removeChild()移除的节点仍然将为文档所有，只不过在文档中已经没有了自己的位置。    </p>
<p>前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用 parentNode 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。    </p>
<h2 id="五、Document类型"><a href="#五、Document类型" class="headerlink" title="五、Document类型"></a>五、Document类型</h2><p>JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点具体有下列特性：   </p>
<ul>
<li>nodeType的值为9</li>
<li>nodeName的值为”#document”</li>
<li>nodeValue的值为null</li>
<li>parentNode的值为null</li>
<li>ownerDocument的值为null</li>
<li>其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProccessingInstrucion或Comment</li>
</ul>
<p>Document类型可以表示HTML页面或者其他基于XML的文档。不过，最常见的应用还是作为HRMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。   </p>
<h3 id="1-文档的子节点"><a href="#1-文档的子节点" class="headerlink" title="1.文档的子节点"></a>1.文档的子节点</h3><p>虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction 或 Comment，但是还有两个内置的访问其子节点的快捷方式。第一个就是 <strong>documentElement</strong> 属性，属性始终指向HTML页面中的html元素。另一个就是通过childNodes列表系列访问文档元素，但通过documentElement属性则能更快捷，更直接地访问该元素。以下面这个简单的页面为例。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html=<span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="built_in">console</span>.log(html===<span class="built_in">document</span>.childNodes[<span class="number">0</span>]);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(html===<span class="built_in">document</span>.firstChild);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>一个页面经过浏览器解析后，其文档中包含一个子节点，即html元素。可以通过documentElement或childNodes列表来访问这个元素。    </p>
<p>作为HTMLDocument的实例，document对象还有一个body属性，直接指向body元素。因为开发人员经常要使用这个元素，所以 <strong>document.body</strong> 在JavaScript代码中出现的频率非常高，其用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="built_in">document</span>.body;</span><br></pre></td></tr></table></figure></p>
<p><strong>所有的浏览器都支持document.documentElement和document.body属性。</strong></p>
<p>Document另一个可能的子节点是DocumentType。通常将标签&lt;!DOCTYPE html&gt;看成一个与文档其他部分不同的实体，可以通过doctype属性（在浏览器中是 <strong>document.doctype</strong> ）来访问它的信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype=<span class="built_in">document</span>.doctype;</span><br></pre></td></tr></table></figure></p>
<p>浏览器对document.doctype的支持差别很大，可以给出如下总结。   </p>
<ul>
<li>IE8及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当做Comment节点；而document.doctype 的值始终为null。</li>
<li>IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype 是一个 DocumentType 节点，也可以通过 document.firstChild 或 document.childNodes[0] 访问同一个节点。</li>
<li>Safari、Chrome 和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个 DocumentType 节点，但该节点不会出现在 document.childNodes 中。</li>
</ul>
<p>由于浏览器对 document.doctype 的支持不一致，因此这个属性的用处很有限。    </p>
<h3 id="2-文档信息"><a href="#2-文档信息" class="headerlink" title="2.文档信息"></a>2.文档信息</h3><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document对象没有的属性。这些属性提供了document对象所表现的网页的一些信息。其中第一个属性就是 title，包含着 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文档标题</span></span><br><span class="line"><span class="keyword">var</span> originalTitle=<span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">//设置文档标题</span></span><br><span class="line"><span class="built_in">document</span>.title=<span class="string">'new Page title'</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下来要介绍的3个属性都与对网页的请求有关，它们是 <strong>URL,domain和referrer</strong>。URL属性中包含网页完整的URL（即地址栏中显示的URL），domain属性中只包含页面的域名，而referrer属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已，如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得完整的URL</span></span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">document</span>.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得域名</span></span><br><span class="line"><span class="keyword">var</span> domain=<span class="built_in">document</span>.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得来源页面的URL</span></span><br><span class="line"><span class="keyword">var</span> referrer=<span class="built_in">document</span>.referrer;</span><br></pre></td></tr></table></figure></p>
<h2 id="六、查找元素"><a href="#六、查找元素" class="headerlink" title="六、查找元素"></a>六、查找元素</h2><p>说到最常见的 DOM 应用，恐怕就要数取得特定的某个或某组元素的引用，然后再执行一些操作了。取得元素的操作可以使用 document 对象的几个方法来完成。Document 类型为此提供了两个方法: <strong>getElementById(),getElementsByTagName()</strong>    </p>
<p>第一个方法，getElementById()，接收一个参数：要取得的元素的 ID。如果找到相应的元素则返回该元素，如果不存在带有相应 ID 的元素，则返回 null。注意，这里的 ID 必须与页面中元素的 id 特性（attribute）严格匹配，包括大小写。以下面的元素为例。    </p>
<p>另一个常用于取得元素引用的方法是 getElementsByTagName()。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的集合。<br>在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态集合”，该对象与NodeList非常相似。例如，下列代码会取得页面中所有的 元素，并返回一个 HTMLCollection。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码会将一个 HTMLCollection 对象保存在 images 变量中。与 NodeList 对象类似，可以使用方括号语法或 item() 方法来访问 HTMLCollection 对象中的项。而这个对象中元素的数量则可以通过其 length 属性取得，如下面的例子所示。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(images.length);        <span class="comment">// 输出图像的数量</span></span><br><span class="line"><span class="built_in">console</span>.log(images[<span class="number">0</span>].src);        <span class="comment">// 输出第一个图像元素的src特性</span></span><br><span class="line"><span class="built_in">console</span>.log(images.item(<span class="number">0</span>).src);   <span class="comment">// 输出第一个图像元素的src特性</span></span><br></pre></td></tr></table></figure>
<p>HTMLCollection 对象还有一个方法，叫做 <strong>namedItem()</strong>，使用这个方法可以通过元素的 name 特性取得集合中的项。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);</span><br></pre></td></tr></table></figure>
<p>要想取得文档中的所有元素，可以向 getElementsByTagName() 中传入 “*“。在 JavaScript 及 CSS 中，星号,通常表示“全部”。   </p>
<p>第三个方法，也只有HTMLDocument类型才有的方法，是 <strong>getElementsByName()</strong> ，顾名思义，这个方法会返回有给定name特性的所有元素。最常见使用这个方法的情况就是取得单选按钮；为了确保发送给浏览器的值正确无误，所有的单选按钮必须具有相同的name特性。    </p>
<h3 id="1-特殊集合"><a href="#1-特殊集合" class="headerlink" title="1.特殊集合"></a>1.特殊集合</h3><p>除了属性和方法，document 对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，为访问文档常用的部分提供了快捷方式，包括：   </p>
<ul>
<li>document.anchors,包含文档中所有带 name 特性的 元素；</li>
<li>document.forms，包含文档中所有的form元素，与document.getElementsByTagName(“form”)得到的结果相同；</li>
<li>document.images，包含文档中所有的img元素，与document.getElementsByTagName(“img”)得到的结果相同；</li>
<li>document.links，包含文档中所有带href特性的a元素;</li>
</ul>
<h3 id="2-文档写入"><a href="#2-文档写入" class="headerlink" title="2.文档写入"></a>2.文档写入</h3><p>有一个 document 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列4个方法中: <strong>write(),writeln(),open()和close()</strong>。其中，write()和writeln()方法都接受一个字符串参数，即要写入输出流中的文本。write() 会原样写入，而 writeln() 则会在字符串的末尾添加一个换行符 \n。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。   </p>
<p>方法open()和close()分别用于打开和关闭网页的输出流。如果是在网页加载期间使用write() 或 writeln() 方法，则不需要用到这两个方法。   </p>
<h1 id="JS中的DOM（二）"><a href="#JS中的DOM（二）" class="headerlink" title="JS中的DOM（二）"></a>JS中的DOM（二）</h1><h2 id="一、Element类型"><a href="#一、Element类型" class="headerlink" title="一、Element类型"></a>一、Element类型</h2><p>除了Document类型之外，Element类型就要算是Web编程中最常用的类型了。Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：   </p>
<ul>
<li>nodeType的值为1；</li>
<li>nodeName的值为元素的标签名</li>
<li>nodeValue的值为null；</li>
<li>parentNode的值可能是Document或Element；</li>
<li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。<br>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。如下：   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.tagName);<span class="comment">//div</span></span><br><span class="line"><span class="built_in">console</span>.log(div.tagName===div.nodeName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的元素标签名是 div，它拥有一个值为 “myDiv” 的ID。可是，div.tagName 实际上输出的是 “DIV” 而非 “div”。在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能这样比较，很容易出错</span></span><br><span class="line"><span class="keyword">if</span>(element.tagName==<span class="string">'div'</span>)&#123;</span><br><span class="line">  <span class="comment">//在此执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样最好</span></span><br><span class="line"><span class="keyword">if</span> (tagName.toLowerCase()===<span class="string">'div'</span>) &#123;</span><br><span class="line">  <span class="comment">//在此执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、HTML元素"><a href="#二、HTML元素" class="headerlink" title="二、HTML元素"></a>二、HTML元素</h2><p>所有的HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：    </p>
<ul>
<li><strong>id</strong>：元素在文档中的唯一标识符</li>
<li><strong>title</strong>：有关元素的附加说明信息，一般通过工具提示条显示出来。</li>
<li><strong>lang</strong>：元素内容的语言代码，很少使用。</li>
<li><strong>dir</strong>：语言的方向，值为‘ltr’（left-to-right，从左到右）或‘rtl’（right-to-left，从右到左），也很少使用</li>
<li><strong>className</strong>：与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class是javascript的保留字。</li>
</ul>
<p>元素中指定的所有信息，都可以通过下列javascript代码取得：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.id);<span class="comment">//'myDIv'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.className);<span class="comment">//'bd'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.title);<span class="comment">//'Body text'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.lang);<span class="comment">//'en'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.dir);<span class="comment">//'ltr'</span></span><br></pre></td></tr></table></figure></p>
<p>当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">div.id=<span class="string">'someOtherId'</span>;</span><br><span class="line">div.className=<span class="string">'ft'</span>;</span><br><span class="line">div.title=<span class="string">'Some Other text'</span>;</span><br><span class="line">div.lang=<span class="string">'fr'</span>;</span><br><span class="line">div.dir=<span class="string">'rtl'</span>;</span><br></pre></td></tr></table></figure></p>
<p>并不是对所有属性的修改都会在页面中直观地表现出来。对 id 或 lang 的修改对用户而言是透明不可见的（假设没有基于它们的值设置的 CSS 样式），而对 title 的修改则只会在鼠标移动到这个元素之上时才会显示出来。对 dir 的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。修改 className 时，如果新类关联了与此前不同的 CSS 样式，那么就会立即应用新的样式。   </p>
<h3 id="1-取得特性"><a href="#1-取得特性" class="headerlink" title="1.取得特性"></a>1.取得特性</h3><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的DOM方法主要有三个，分别是 <strong>getAttribute(),setAttribute()和removeAttribute()</strong>。这三个方法可以针对任何特性使用，包括哪些以HTMLElement类型属性的形式定义的特性。来看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'id'</span>));<span class="comment">//'myDiv'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'class'</span>));<span class="comment">//'bd'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'title'</span>));<span class="comment">//'Body text'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'lang'</span>));<span class="comment">//'en'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'dir'</span>));<span class="comment">//'ltr'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，传递给getAttribute()的特性名与实际的特姓名相同。因此要想得到class特性值，应该出入’class’而不是‘className’，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，getAttribute()返回null。<br>通过getAttribute()方法也可以取得自定义特性（即标准HTML语言中没有的特性）的值，以下面的元素为例：   </p>
<p>这个元素包含一个名为my_special_attribute的自定义特性，它的值是’hello’。可以像取得其他特性一样取得这个值，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value=div.getAttribute(<span class="string">'my_special_attribute'</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过，特性的名称是不区分大小写的，即‘ID’和‘id’代表的都是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。   </p>
<p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不同。第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。由于style属性是用于以编程方式访问元素样式的，因此并么有直接映射到style特性。   </p>
<p>第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是javascript代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则返回一个javascript函数（如果未在元素中指定相应特性，则返回null）。这是因为onclick及其他事件处理程序属性本身就应该被赋予函数值。   </p>
<p>由于存在这些差别，在通过 JavaScript 以编程方式操作 DOM 时，开发人员经常不使用 getAttribute()，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用 getAttribute() 方法。   </p>
<h3 id="2-设置特性"><a href="#2-设置特性" class="headerlink" title="2.设置特性"></a>2.设置特性</h3><p>与getAttribute()对应的方法是 <strong>setAttribute()</strong>，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性相应的值。来看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(<span class="string">'id'</span>,<span class="string">'someOtherId'</span>);</span><br><span class="line">div.setAttribute(<span class="string">'class'</span>,<span class="string">'ft'</span>);</span><br><span class="line">div.setAttribute(<span class="string">'lang'</span>,<span class="string">'fr'</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置特性名会被统一转换为小写形式，即”ID”最终会变成“id”。<br>因为所有的特性都是属性，所以一直给属性赋值可以设置特性的值，如下所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.id=<span class="string">'someOtherId'</span>;</span><br><span class="line">div.align=<span class="string">'left'</span>;</span><br></pre></td></tr></table></figure></p>
<p>不过，像下面这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.mycolor=<span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.mycolor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">// null（IE除外）</span></span><br></pre></td></tr></table></figure></p>
<p>要介绍的最后一个方法是 <strong>removeAttribute()</strong>，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.removeAttribute(<span class="string">'class'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个方法并不常用，但在序列化 DOM 元素时，可以通过它来确切地指定要包含哪些特性。   </p>
<h2 id="三、创建元素"><a href="#三、创建元素" class="headerlink" title="三、创建元素"></a>三、创建元素</h2><p>使用 <strong>document.createElement()</strong> 方法可以创建一个新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写。例如，使用下面的代码可以创建一个div元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。此时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。来看下面的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.id=<span class="string">'myNewDiv'</span>;</span><br><span class="line">div.className=<span class="string">'box'</span>;</span><br></pre></td></tr></table></figure></p>
<p>在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素向未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、insertBefore()或replaceChild()方法。下面的代码会把新创建的元素添加到文档的body元素中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure></p>
<p>一旦将元素添加到文档树中，浏览器就会立即呈现该有的元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p>
<h2 id="四、元素的子节点"><a href="#四、元素的子节点" class="headerlink" title="四、元素的子节点"></a>四、元素的子节点</h2><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。<br>元素的childNodes属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点，注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同，以下面的代码为例。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果是IE8来解析这些代码，那么ul元素会有3个子节点，分别是3个li元素。但是如果在其他浏览器中，ul元素会有7个元素。包括3个li元素和4个文本节点（li元素之间的空白符）。如果想下面这样讲元素间的空白删除，那么所有的浏览器都会返回相同数目的子节点。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'myList'</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于这段代码，元素在任何浏览器中都会包含3个子节点。如果需要通过childNodes属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下nodeType属性，如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=element.childNodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.childNodes[i].nodeType==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//执行某些操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子会循环遍历特定元素的每个子节点，然后只在子节点的nodeType等于1（表示是元素节点）的情况下，才会执行某些操作。<br>如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持 getElementsByTagName() 方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过 document 调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面ul元素中包含的所有li元素，可以使用下列代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span><br><span class="line"><span class="keyword">var</span> items=ul.getElementsByTagName(<span class="string">'li'</span>);</span><br></pre></td></tr></table></figure></p>
<p>要注意的是，这里的后代直接子元素，不过，如果它包含更多层次的后代元素，那么各个层次中包含的li元素都会返回。   </p>
<h2 id="五、Text类型"><a href="#五、Text类型" class="headerlink" title="五、Text类型"></a>五、Text类型</h2><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特征：  </p>
<ul>
<li>nodeType的值为3</li>
<li>nodeName的值为”#text”</li>
<li>nodeValue的值为节点包含的文本</li>
<li>parentNode是一个Element</li>
<li>不支持（没有）子节点<br>可以通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本。   </li>
<li>appendData(text):将text添加到节点的末尾</li>
<li>deleteData(offset,count):从offset指定的位置开始删除count个字符</li>
<li>insertData(offset，text)：在offset指定的位置插入text</li>
<li>replaceData(offset,count,text):用text替换从offset指定的位置开始到offset+count文本。</li>
<li>splitText(offset):从offset指定的位置将当前文本节点分成两个文本节点。   </li>
<li>substringData(offset,count):提取从offset指定的位置开始到offset+count为为止出的子串。   </li>
</ul>
<p>除了这些方法之外，文本节点还有一个length属性，保存着节点中字符的数目。而且，nodeValue.length和data.length中也保存着同样的值。<br>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。来看几个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--没有内容，也就没有文本节点--&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;!-- 有空格，因而有一个文本节点 --&gt;</span><br><span class="line">&lt;div&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;!-- 有内容，因而有一个文本节点 --&gt;</span><br><span class="line">&lt;div&gt;Hello World!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面代码给出的第一个元素没有内容，因此也就不存在文本节点。开始与结束标签之间只要存在内容，就会创建一个文本节点。因此，第二个元素中虽然只包含一个空格，但仍然有一个文本子节点；文本节点的nodeVlaue值是一个空格。第二个div也有一个文本节点，其nodeValue的值为“hello world”。可以使用以下代码来访问这些文本子节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode=div.firstChild;<span class="comment">//或者div.childNodes[0]</span></span><br></pre></td></tr></table></figure></p>
<p>在取得了文本节点的引用后，就可以向下面这样来修改它了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.firstChild.nodeValue=<span class="string">'Some other message'</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果这个文本节点当前存在于文档树中，那么修改文本节点的结构就会立即得到反映。另外，在修改文本节点时还需要注意，此时的字符串会经过HTML（或XML，取决于文档类型）编码。换句话说，小于还、大于号或引号都会像下面的例子一样被转义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"</span></span><br><span class="line">div.firstChild.nodeValue=<span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span></span><br></pre></td></tr></table></figure></p>
<p>应该说，这是向DOM文档中插入文本之前，先对其进行HTML编码的一种有效方式。   </p>
<blockquote>
<p>在 IE8、Firefox、Safari、Chrome 和 Opera中，可以通过脚本访问 Text 类型的构造函数和原型。</p>
</blockquote>
<h3 id="1-创建文本节点"><a href="#1-创建文本节点" class="headerlink" title="1.创建文本节点"></a>1.创建文本节点</h3><p>可以使用 <strong>document.createTextNode()</strong> 创建新文本节点，这个方法接受一个参数————要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也可以按照HTML或XML的格式进行编码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">'&lt;strong&gt;Hello&lt;/strong&gt; world!'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在创建新文本节点的同时，也会为其设置ownerDocument属性。不过，除非把新节点添加到文档树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个元素并向其中添加一条消息。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.className=<span class="string">'message'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">'hello wworld'</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure>
<p>如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。   </p>
<h3 id="2-规范化文本节点"><a href="#2-规范化文本节点" class="headerlink" title="2.规范化文本节点"></a>2.规范化文本节点</h3><p>DOM 文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM 文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由 Node 类型定义的（因而在所有节点类型中都存在），名叫 <strong>normalize()</strong>。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前一个文本节点的nodeVlaue值拼接起来的值。来看一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.className=<span class="string">'message'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">'hello world'</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Yippee!"</span>);</span><br><span class="line">element.appendChild(anotherTextNode);</span><br><span class="line"></span><br><span class="line">element.normalize();</span><br><span class="line"><span class="built_in">console</span>.log(element.childNodes.length);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(element.firstChild.nodeValue);<span class="comment">//"Hello world!Yippee!"</span></span><br></pre></td></tr></table></figure></p>
<p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。     </p>
<h3 id="3-分割文本节点"><a href="#3-分割文本节点" class="headerlink" title="3.分割文本节点"></a>3.分割文本节点</h3><p>Text类型提供了一个作用于normalize()相反的方法splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定位置分割nodeValue的值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。</p>
<h2 id="六、Comment类型"><a href="#六、Comment类型" class="headerlink" title="六、Comment类型"></a>六、Comment类型</h2><p>注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：</p>
<ul>
<li>nodeType的值为8</li>
<li>nodeName的值为“#comment</li>
<li>nodeValue的值是注释的内容</li>
<li>parentNode可能是Document或Element</li>
<li>不支持（没有）子节点<br>Comment 类型与 Text 类型继承自相同的基类，因此它拥有除splitText() 之外的所有字符串操作方法。与 Text 类型相似，也可以通过 nodeValue 或 data 属性来取得注释的内容。<br>注释节点可以通过其父节点来访问，以下面的代码为例。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'myDiv'</span>&gt;</span><span class="comment">&lt;!--A comment--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在此，注释节点是元素的一个子节点，因此可以通过下面的代码来访问它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> comment = div.firstChild;</span><br><span class="line"><span class="built_in">console</span>.log(comment.data);    <span class="comment">// "A comment"</span></span><br></pre></td></tr></table></figure></p>
<p>另外，使用document.createComment()并为其传递注释文本也可以创建注释节点，如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comment=<span class="built_in">document</span>.createComment(<span class="string">'A comment'</span>);</span><br></pre></td></tr></table></figure></p>
<p>显然，开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。此外，浏览器也不会识别位于 标签后面的注释。一定要保证它们位于html标签内。</p>
<h2 id="七、Attr类型"><a href="#七、Attr类型" class="headerlink" title="七、Attr类型"></a>七、Attr类型</h2><p>元素的特性在 DOM 中以 Attr 类型来表示。在所有浏览器中（包括 IE8），都可以访问 Attr 类型的构造函数和原型。从技术角度讲，特性就是存在于元素的 attributes 属性中的节点。特性节点具有下列特征：   </p>
<ul>
<li>nodeType 的值为11；</li>
<li>nodeName 的值是特性的名称；</li>
<li>nodeValue 的值是特性的值；</li>
<li>parentNode 的值为 null；</li>
<li>在 HTML 中不支持（没有）子节点；</li>
<li>在 XML 中子节点可以是 Text或 EntityReference。 尽管它们也是节点，但特性却不被认为是 DOM 文档树的一部分。开发人员最常使用的是 getAttribute()、setAttribute() 和 remveAttribute() 方法，很少直接引用特性节点。</li>
</ul>
<p>Attr 对象有3个属性：<strong>name、value 和 specified</strong>。其中，name 是特性名称（与 nodeName 的值相同），value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。    </p>
<p>使用document.createAttribute()并换入特性的名称可以创建新的特性节点。例如，要为元素添加align特性，可以使用下列代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attr=<span class="built_in">document</span>.createAttribute(<span class="string">'align'</span>);</span><br><span class="line">attr.align=<span class="string">'left'</span>;</span><br><span class="line">element.setAttributeNode(attr);</span><br><span class="line"><span class="built_in">console</span>.log(element.attributes[<span class="string">'align'</span>].value);<span class="comment">//left</span></span><br><span class="line"><span class="built_in">console</span>.log(element.getAttributeNode(<span class="string">'align'</span>).value);<span class="comment">//left</span></span><br><span class="line"><span class="built_in">console</span>.log(element.getAttribute(<span class="string">'align'</span>));<span class="comment">//left</span></span><br></pre></td></tr></table></figure></p>
<p>添加特性之后，可以通过下列任何方式访问该特性：  </p>
<ul>
<li>attributes属性</li>
<li>getAttribute()方法</li>
<li>getAttributeNode()方法<br>ttributes 和 getAttributeNode() 都会返回对应特性的 Attr 节点，而 getAttribute() 则只返回特性的值。   </li>
</ul>
<h2 id="八、DOM操作"><a href="#八、DOM操作" class="headerlink" title="八、DOM操作"></a>八、DOM操作</h2><p>很多时候，DOM 操作都比较简明，因此用 JavaScript 生成那些通常原本是用 HTML 代码生成的内容并不麻烦。不过，也有一些时候，操作 DOM 并不像表面上看起来那么简单。由于浏览器中充斥着隐藏的陷阱和不兼容问题，用 JavaScript 代码处理 DOM 的某些部分要比处理其他部分更复杂一些。   </p>
<h3 id="1-动态脚本"><a href="#1-动态脚本" class="headerlink" title="1.动态脚本"></a>1.动态脚本</h3><p>使用script标签可以向页面中插入JavaScript代码，一种方式是通过其 src 特性包含外部文件，另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加的脚本。跟操作 HTML 元素一样，创建动态脚本也有两种方式：插入外部外部文件和直接插入 JavaScript 代码。<br>动态加载的外部JavaScript文件能够立即运行，比如下面的sript元素。   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span> <span class="attr">src</span>=<span class="string">'client.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建这个DOM节点的代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.type=<span class="string">'text/javascript'</span>;</span><br><span class="line">  script.src=url;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是调用这个函数的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadSScript(<span class="string">'client.js'</span>);</span><br></pre></td></tr></table></figure></p>
<p>另一种指定javascript代码的方式行内方式，如下面的例子所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从逻辑上讲，下面的操作DOM代码是有效的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.type=<span class="string">'text/javascript'</span>;</span><br><span class="line">script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"function sayHi()&#123;alert('hi);&#125;"</span>));</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p>
<p>在 Firefox、Safari、Chrome 和 Opera 中，这些 DOM 代码可以正常运行。但在 IE 中，则会导致错误。IE将script视为特殊的元素，不允许DOM访问其子节点。不过，可以使用script元素的text 属性来指定 JavaScript 代码，像下面的例子这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.type=<span class="string">'text/javascript'</span>;</span><br><span class="line">script.text=<span class="string">'function sayHi()&#123;alert('</span>hi<span class="string">');&#125;'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p>
<p>整个过程可以以下函数表示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type=<span class="string">'text/javascript'</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      script.text=code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadScriptString(<span class="string">'function sayHi()&#123;alert('</span>hi<span class="string">');&#125;'</span>);</span><br></pre></td></tr></table></figure></p>
<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 eval() 是一样的。   </p>
<h3 id="2-动态样式"><a href="#2-动态样式" class="headerlink" title="2.动态样式"></a>2.动态样式</h3><p>能够把 CSS 样式包含到 HTML 页面中的元素有两个。其中，link标签 元素用于包含来自外部的文件，而 style标签 元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。我们以下面这个典型的link元素为例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用DOM代码可以很容易地动态创建出这个元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyle</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link=dcoument.createElement(<span class="string">'link'</span>);</span><br><span class="line">  link.rel=<span class="string">'stylesheet'</span>;</span><br><span class="line">  link.type=<span class="string">'text/css'</span>;</span><br><span class="line">  link.href=url;</span><br><span class="line">  <span class="keyword">var</span> head=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">  head.appendChild(link);</span><br><span class="line">&#125;</span><br><span class="line">loadStyles(<span class="string">"styles.css"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上代码在所有主流浏览器中都可以正常运行。需要注意的是，必须将 <link> 元素添加到 <head> 而不是 </head><body> 元素，才能保证在所有浏览器中的行为一致。<br>加载外部样式文件的过程是异步的，也就是加载样式的过程没有固定的次序。一般来说，知不知道样式已经加载完成并不重要。<br>另一种定义样式的方式是使用style元素来包含嵌入式CSS，如下所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body&#123;background-color:red&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></body></p>
<p>按照同样的逻辑，下列DOM代码应该是有效的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style=<span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">  style.type=<span class="string">'text/css'</span>;</span><br><span class="line">  style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"body&#123;background-color:red&#125;"</span>));</span><br><span class="line">  <span class="keyword">var</span> head=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">  head.appendChild(style);</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以在 Firefox、Safari、Chrome 和 Opera 中运行，在 IE 中则会报错。IE将 style 视为一个特殊的、与 script 类似的节点，不允许访问其子节点。事实上，IE 此时抛出的错误与向 script 元素添加子节点时抛出的错误相同。解决 IE 中这个问题的办法，就是访问元素的 styleSheet 属性，该属性又有一个 cssText 属性，可以接受 CSS 代码），如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> style=<span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">  style.type=<span class="string">"text/css"</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(css))</span><br><span class="line">  &#125;cath(e)&#123;</span><br><span class="line">    style.styleSheet.cssText=css;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> head=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">  head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line">loadStyleString(<span class="string">"body&#123;background-color:red&#125;"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种方式会实时地向页面中添加样式，因此能够马上看到变化。   </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。<br>DOM 由各种节点构成，简要总结如下。   </p>
<ul>
<li>最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。</li>
<li>Document类型表示整个文档，是一组分层节点的根节点。在javascript中，document对象时Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。</li>
<li>Element节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。</li>
<li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。</li>
</ul>
<p>访问 DOM 的操作在多数情况下都很直观，不过在处理 <script> 和 <style> 元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用 innerHTML 时，以及在创建新元素时的一些问题。<br>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。    </p>
<p><a href="https://juejin.im/post/583cbc4961ff4b006ccc44fb">原文地址</a></p>
</script></p>
      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.png" alt="稻香Snowy wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="稻香Snowy 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript进阶/" rel="tag"><i class="fa fa-tag"></i> JavaScript进阶</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/JavaScript/JS初探十二（ES6相关介绍）/" rel="next" title="JS初探十二（ES6相关介绍）">
                <i class="fa fa-chevron-left"></i> JS初探十二（ES6相关介绍）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/JavaScript/JS进阶二（JS中的BOM）/" rel="prev" title="JS进阶二（JS中的DOM）">
                JS进阶二（JS中的DOM） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/toux.jpg"
                alt="稻香Snowy" />
            
              <p class="site-author-name" itemprop="name">稻香Snowy</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry.Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Asiazdx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/fb5f478b1a94" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/59638598f265da6c4523c761" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-spinner"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5541828133/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-Weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JS中的DOM（一）"><span class="nav-number">1.</span> <span class="nav-text">JS中的DOM（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、节点层次"><span class="nav-number">1.1.</span> <span class="nav-text">一、节点层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Node类型"><span class="nav-number">1.2.</span> <span class="nav-text">二、Node类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Node属性概述"><span class="nav-number">1.3.</span> <span class="nav-text">二、Node属性概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-nodeName和nodeValue属性"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.nodeName和nodeValue属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、节点关系"><span class="nav-number">1.4.</span> <span class="nav-text">三、节点关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、操作节点"><span class="nav-number">1.5.</span> <span class="nav-text">四、操作节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Document类型"><span class="nav-number">1.6.</span> <span class="nav-text">五、Document类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-文档的子节点"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.文档的子节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-文档信息"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.文档信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、查找元素"><span class="nav-number">1.7.</span> <span class="nav-text">六、查找元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-特殊集合"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.特殊集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-文档写入"><span class="nav-number">1.7.2.</span> <span class="nav-text">2.文档写入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS中的DOM（二）"><span class="nav-number">2.</span> <span class="nav-text">JS中的DOM（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、Element类型"><span class="nav-number">2.1.</span> <span class="nav-text">一、Element类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、HTML元素"><span class="nav-number">2.2.</span> <span class="nav-text">二、HTML元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-取得特性"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.取得特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-设置特性"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.设置特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、创建元素"><span class="nav-number">2.3.</span> <span class="nav-text">三、创建元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、元素的子节点"><span class="nav-number">2.4.</span> <span class="nav-text">四、元素的子节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Text类型"><span class="nav-number">2.5.</span> <span class="nav-text">五、Text类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建文本节点"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.创建文本节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-规范化文本节点"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.规范化文本节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-分割文本节点"><span class="nav-number">2.5.3.</span> <span class="nav-text">3.分割文本节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、Comment类型"><span class="nav-number">2.6.</span> <span class="nav-text">六、Comment类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、Attr类型"><span class="nav-number">2.7.</span> <span class="nav-text">七、Attr类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、DOM操作"><span class="nav-number">2.8.</span> <span class="nav-text">八、DOM操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-动态脚本"><span class="nav-number">2.8.1.</span> <span class="nav-text">1.动态脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-动态样式"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.动态样式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">2.9.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">稻香Snowy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
</body>

<script>
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var cw = canvas.width = window.innerWidth,
  cx = cw / 2;
var ch = canvas.height = window.innerHeight,
  cy = ch / 2;

ctx.fillStyle = "#999";
var linesNum = 16;
var linesRy = [];
var requestId = null;

function Line(flag) {
  this.flag = flag;
  this.a = {};
  this.b = {};
  if (flag == "v") {
    this.a.y = 0;
    this.b.y = ch;
    this.a.x = randomIntFromInterval(0, ch);
    this.b.x = randomIntFromInterval(0, ch);
  } else if (flag == "h") {
    this.a.x = 0;
    this.b.x = cw;
    this.a.y = randomIntFromInterval(0, cw);
    this.b.y = randomIntFromInterval(0, cw);
  }
  this.va = randomIntFromInterval(25, 100) / 100;
  this.vb = randomIntFromInterval(25, 100) / 100;

  this.draw = function() {
    ctx.strokeStyle = "#ccc";
    ctx.beginPath();
    ctx.moveTo(this.a.x, this.a.y);
    ctx.lineTo(this.b.x, this.b.y);
    ctx.stroke();
  }

  this.update = function() {
    if (this.flag == "v") {
      this.a.x += this.va;
      this.b.x += this.vb;
    } else if (flag == "h") {
      this.a.y += this.va;
      this.b.y += this.vb;
    }

    this.edges();
  }

  this.edges = function() {
    if (this.flag == "v") {
      if (this.a.x < 0 || this.a.x > cw) {
        this.va *= -1;
      }
      if (this.b.x < 0 || this.b.x > cw) {
        this.vb *= -1;
      }
    } else if (flag == "h") {
      if (this.a.y < 0 || this.a.y > ch) {
        this.va *= -1;
      }
      if (this.b.y < 0 || this.b.y > ch) {
        this.vb *= -1;
      }
    }
  }

}

for (var i = 0; i < linesNum; i++) {
  var flag = i % 2 == 0 ? "h" : "v";
  var l = new Line(flag);
  linesRy.push(l);
}

function Draw() {
  requestId = window.requestAnimationFrame(Draw);
  ctx.clearRect(0, 0, cw, ch);

  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    l.draw();
    l.update();
  }
  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    for (var j = i + 1; j < linesRy.length; j++) {
      var l1 = linesRy[j]
      Intersect2lines(l, l1);
    }
  }
}

function Init() {
  linesRy.length = 0;
  for (var i = 0; i < linesNum; i++) {
    var flag = i % 2 == 0 ? "h" : "v";
    var l = new Line(flag);
    linesRy.push(l);
  }

  if (requestId) {
    window.cancelAnimationFrame(requestId);
    requestId = null;
  }

  cw = canvas.width = window.innerWidth,
    cx = cw / 2;
  ch = canvas.height = window.innerHeight,
    cy = ch / 2;

  Draw();
};

setTimeout(function() {
  Init();

  addEventListener('resize', Init, false);
}, 15);

function Intersect2lines(l1, l2) {
  var p1 = l1.a,
    p2 = l1.b,
    p3 = l2.a,
    p4 = l2.b;
  var denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
  var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
  var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
  var x = p1.x + ua * (p2.x - p1.x);
  var y = p1.y + ua * (p2.y - p1.y);
  if (ua > 0 && ub > 0) {
    markPoint({
      x: x,
      y: y
    })
  }
}

function markPoint(p) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
  ctx.fill();
}

function randomIntFromInterval(mn, mx) {
  return ~~(Math.random() * (mx - mn + 1) + mn);
}

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</script>
</html>
