<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #AFDBE3; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #AFDBE3, 0 0 5px     #AFDBE3; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #AFDBE3;    /*上边框颜色*/
        border-left-color: #AFDBE3;    /*左边框颜色*/
    }
</style>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="git," />










<meta name="description" content="多种多样的工作流使得在项目中实施Git时变得难以选择。这份教程提供了一个出发点，调查企业团队最常见的Git工作流。当然工作流应该是一种规范而不是金科玉律。我们应该融汇贯通，因地制宜找到适合自己团队项目的流程即可。">
<meta name="keywords" content="git">
<meta property="og:type" content="article">
<meta property="og:title" content="git学习笔记六（git在团队开发中的工作流程）">
<meta property="og:url" content="http://www.github.com/Snowyzdx/版本控制工具/git学习笔记六（git在团队开发中的工作流）/index.html">
<meta property="og:site_name" content="Snowy&#39;blog">
<meta property="og:description" content="多种多样的工作流使得在项目中实施Git时变得难以选择。这份教程提供了一个出发点，调查企业团队最常见的Git工作流。当然工作流应该是一种规范而不是金科玉律。我们应该融汇贯通，因地制宜找到适合自己团队项目的流程即可。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf01.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf02.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf03.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf04.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf05.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf08.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf06.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf07.png">
<meta property="og:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf09.png">
<meta property="og:updated_time" content="2018-04-17T11:11:29.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git学习笔记六（git在团队开发中的工作流程）">
<meta name="twitter:description" content="多种多样的工作流使得在项目中实施Git时变得难以选择。这份教程提供了一个出发点，调查企业团队最常见的Git工作流。当然工作流应该是一种规范而不是金科玉律。我们应该融汇贯通，因地制宜找到适合自己团队项目的流程即可。">
<meta name="twitter:image" content="http://p6nfblqvu.bkt.clouddn.com/gitf.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="http://www.github.com/Snowyzdx/版本控制工具/git学习笔记六（git在团队开发中的工作流）/"/>





  <title>git学习笔记六（git在团队开发中的工作流程） | Snowy'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Asiazdx"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Snowy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Stay Hungry. Stay Foolish</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-comments">
          <a href="/comments/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heart"></i> <br />
            
            留言板
          </a>
        </li>
      
        
        <li class="menu-item menu-item-laboratory">
          <a href="/laboratory/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />
            
            实验室
          </a>
        </li>
      
        
        <li class="menu-item menu-item-other_note">
          <a href="/other_note/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书影音
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.github.com/Snowyzdx/版本控制工具/git学习笔记六（git在团队开发中的工作流）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="稻香Snowy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/toux.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Snowy'blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">git学习笔记六（git在团队开发中的工作流程）</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-07T11:03:28+08:00">
                2017-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/版本控制工具/" itemprop="url" rel="index">
                    <span itemprop="name">版本控制工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf.png" alt="gitf"><br>多种多样的工作流使得在项目中实施Git时变得难以选择。这份教程提供了一个出发点，调查企业团队最常见的Git工作流。<br>当然工作流应该是一种规范而不是金科玉律。我们应该融汇贯通，因地制宜找到适合自己团队项目的流程即可。<br><a id="more"></a><br>本文主要讨论下面四种工作流：   </p>
<ul>
<li>中心化的工作流</li>
<li>基于功能分支的工作流</li>
<li>Gitflow工作流</li>
<li>Fork工作流</li>
</ul>
<h2 id="一、中心化的工作流"><a href="#一、中心化的工作流" class="headerlink" title="一、中心化的工作流"></a>一、中心化的工作流</h2><p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf01.png" alt="gitf01"><br>过渡到分布式版本控制系统看起来是个令人恐怖的任务，但你不必为了利用Git的优点而改变你现有的工作流程。你的团队仍然可以用以前的SVN的方式开发项目。   </p>
<p>然而，使用Git来驱动你的开发工作流显示了一些SVN没有的优点。首先，它让每个开发者都有了自己本地的完整项目副本。隔离的环境使得每个开发者的工作独立于项目的其他修改（他们可以在自己的本地仓库中添加提交，完全无视上游的开发，直到需要的时候）    </p>
<p>第二，它让你接触到了git的分支和合并模型。和SVN不同，Git分支被设计为一种故障安全的机制，用来在仓库之间整合代码和共享更改。    </p>
<h3 id="1-如何工作"><a href="#1-如何工作" class="headerlink" title="1.如何工作"></a>1.如何工作</h3><p>和SVN一样，中心化的工作流将中央仓库作为项目中所有修改的唯一入口。和trunk不同，默认的开发分支叫做master，所有更改都被提交到这个分支。这种工作流不需要master之外的其他分支。    </p>
<p>开发者将中央仓库克隆到本地后开始工作。在他们的本地项目副本中，他们可以像SVN一样修改文件和提交更改；不过，这些新的提交被保存在本地——它们和中央仓库完全隔离。这使得开发者可以将上游的同步推迟到他们方便的时候。    </p>
<p>为了向官方项目发布修改，开发者将他们的本地master分支推送到中央仓库。这一步等同于svn commit，除了Git添加的是所有不在中央master分支上的本地提交。<br><img src="http://p6nfblqvu.bkt.clouddn.com/gitf02.png" alt="gitf02">    </p>
<p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf03.png" alt="gitf03">   </p>
<h3 id="2、管理冲突"><a href="#2、管理冲突" class="headerlink" title="2、管理冲突"></a>2、管理冲突</h3><p>中央仓库代表官方项目，因此它们的提交历史应该被视作神圣不可更改的。如果开发者的本地提交和中央仓库分叉了,Git会拒绝将他们的修改推送上去，因为这会覆盖官方提交。   </p>
<p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf04.png" alt="gitf04">   </p>
<p>在开发者发布他们的功能之前，他们需要fetch更新的中央体积提交，在他们之上rebase自己的更改，这就像是[我想要在其他人的工作进展上添加我的修改]，它会产生完美的线性历史，就像和传统的SVN工作流一样。    </p>
<p>如果本地修改和上游修改提交冲突时，Git会暂停rebase流程，给你机会手动修改解决这些冲同。Git很赞的一点就是，它将git status和git add命令同时用来提交和解决合并冲同。这使得开发者能够晴轻而易举地管理他们的合并。另外，如果它们改错了什么，Git让他们轻而易举地退出rebase过程，然后重试（或者找人帮忙）。    </p>
<h3 id="1、例子"><a href="#1、例子" class="headerlink" title="1、例子"></a>1、例子</h3><p>让我们一步步观察一个普通的小团队是如何使用这种工作流协作的。我们有两位开发者，A和B，分别在开发两个功能，他们通过中心化的仓库共享代码。   </p>
<h4 id="（1）、一人初始化了中央仓库"><a href="#（1）、一人初始化了中央仓库" class="headerlink" title="（1）、一人初始化了中央仓库"></a>（1）、一人初始化了中央仓库</h4><p>首先，需要有人在服务器上创建中央仓库。如果这是一个新项目，你可以初始化一个空仓库。不然，你需要导入一个已经存在Git或SVN项目。<br>首先A先在github上创建一个中央仓库（名为teamApp）。   </p>
<h4 id="（2）、所有人将仓库克隆到本地"><a href="#（2）、所有人将仓库克隆到本地" class="headerlink" title="（2）、所有人将仓库克隆到本地"></a>（2）、所有人将仓库克隆到本地</h4><p>接下来，每个开发者在本地创建一分完整的项目副本。使用 <strong>git clone</strong> 命令。<br>当你克隆仓库时，Git自动添加一个名为origin的远程连接，指向[父]仓库，以便你以后和这个仓库交换数据。   </p>
<h4 id="（3）、-A在开发他的功能"><a href="#（3）、-A在开发他的功能" class="headerlink" title="（3）、 A在开发他的功能"></a>（3）、 A在开发他的功能</h4><p>在他的本地仓库中，A可以用标准的Git提交流程开发功能：编辑，缓存，提交。如果你对缓存区还不熟悉，你也可以不用记录工作目录中每次的变化。于是你创建了一个高度集中的提交，即使已经在本地做了做了很多修改。   </p>
<blockquote>
<p>git status #查看仓库状态<br>git add <some-file> #缓存一个文件<br>git commit #提交一个文件</some-file></p>
</blockquote>
<p>记住，这些命令创建的是本地提交，A可以周而复始地重复这个过程，而不用考虑中央仓库。对于庞大的功能，需要切换成更简单、原子化的片段，这个特点就很有用。   </p>
<h4 id="（4）、B在开发他的功能"><a href="#（4）、B在开发他的功能" class="headerlink" title="（4）、B在开发他的功能"></a>（4）、B在开发他的功能</h4><p>同时，B在她自己的本地仓库用相同的编辑、缓存、提交流程开发她的功能。和A一样，他不需要关心中央仓库的进展，他也不关心B在他自己仓库中做的事，因为所有本地仓库都是私有的。   </p>
<h4 id="（5）、A发布了他的功能"><a href="#（5）、A发布了他的功能" class="headerlink" title="（5）、A发布了他的功能"></a>（5）、A发布了他的功能</h4><p>一旦A完成了他的功能，他应该将本地提交发布到中央仓库，这样其他项目成员就可以访问了。他可以使用git push命令，就像：   </p>
<blockquote>
<p>git push origin master</p>
</blockquote>
<p>记住，origin是A克隆中央仓库时指向它的远程连接。master参数告诉Git试着将origin的master分支变得和他本地的master分支一样。中央仓库在A克隆之后还没有进展，因此这个推送如他所愿，没有产生冲突。    </p>
<h4 id="（6）、B试图发布他的功能"><a href="#（6）、B试图发布他的功能" class="headerlink" title="（6）、B试图发布他的功能"></a>（6）、B试图发布他的功能</h4><p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf05.png" alt="gitf05"><br>A已经成功地将他的更改发布到了中央仓库上，看看当B试着将他的功能推送到上面时会发生什么。她可以使用同一个推送命令：   </p>
<blockquote>
<p>git push origin master</p>
</blockquote>
<p>但是，他的本地历史和中央仓库已经分叉了，Git会拒绝这个请求，并显示一段冗长的错误信息:<br><img src="http://p6nfblqvu.bkt.clouddn.com/gitf08.png" alt="gitf08">  </p>
<p>Git防止B覆盖官方的修改。他需要将A的更新拉取到他的仓库，和他的本地仓库修改整合后在重试。   </p>
<h4 id="（7）、B在A的提交上rebase"><a href="#（7）、B在A的提交上rebase" class="headerlink" title="（7）、B在A的提交上rebase"></a>（7）、B在A的提交上rebase</h4><p>A可以使用git pull将上游修改并入他的仓库。这个命令和SVN update很像（它拉取整个上游提交历史到B的仓库并和他的本地仓库提交一起整合）   </p>
<blockquote>
<p>git pull –rebase origin master</p>
</blockquote>
<p>–rebase选项告诉Git，在同步了中央仓库的修改之后，将B所有的提交移到master分支的顶端，如下图所示<br><img src="http://p6nfblqvu.bkt.clouddn.com/gitf06.png" alt="gitf06"><br>如果你忽略这个选项拉取同样会成功，只不过你每一和中央仓库同步时都会多出一个[合并提交]。在这种工作流中，rebase和生成一个合并提交相比，总是一个更好的选择。   </p>
<h4 id="（8）、B解决了合并冲突"><a href="#（8）、B解决了合并冲突" class="headerlink" title="（8）、B解决了合并冲突"></a>（8）、B解决了合并冲突</h4><p>rebase的工作是将每个本地提交一个个转移到更新后的master分支。也就是说，你可以一个个提交分别解决合并冲突，而不是在一个庞大的合并提交中解决。它会让你的每个提交保持专注，并获得一个干净的项目历史。另一方面，你更容易发现bug是在哪引入的，如果有必要的话，用最小的代价回滚这些修改。   </p>
<p>如果A和B开发的功能没有关联，rebase的过程不可能出现冲突。但如果出现冲突时，Git 在当前提交会暂停 rebase，输出下面的信息，和一些相关的指令：   </p>
<blockquote>
<p>CONFLICT (content): Merge conflict in <some-file></some-file></p>
</blockquote>
<p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf07.png" alt="gitf07"><br>Git的优点在于每个人都能解决他们自己的合并冲突。在这个例子中，B只需运行一下git status就可以发现问题是什么。冲突的文件会出现在未合并路径中：    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Unmerged paths:</span><br><span class="line"># (use "git reset HEAD &lt;some-file&gt;..." to unstage)</span><br><span class="line"># (use "git add/rm &lt;some-file&gt;..." as appropriate to mark resolution)</span><br><span class="line">#</span><br><span class="line"># both modified: &lt;some-file&gt;</span><br></pre></td></tr></table></figure>
<p>接下来，修改这些文件。如果她对你结果满意了，和往常一样缓存这些文件，然后让git rebase完成接下来的工作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;some-file&gt;</span><br><span class="line">$ git rebase --<span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<p>就是这样，Git会继续检查下个提交，对冲突的提交重复这个流程。<br>如果你这时候发现不知道自己做了什么，不要惊慌。只要运行下面的命令，你就会回到开始之前的状态：   </p>
<blockquote>
<p>git rebase –abort</p>
</blockquote>
<h4 id="（9）、B成功发布了他的分支"><a href="#（9）、B成功发布了他的分支" class="headerlink" title="（9）、B成功发布了他的分支"></a>（9）、B成功发布了他的分支</h4><p>在他和中央仓库同步后，B可以成功地发布他的修改：   </p>
<blockquote>
<p>git push origin master</p>
</blockquote>
<h4 id="（10）、小结"><a href="#（10）、小结" class="headerlink" title="（10）、小结"></a>（10）、小结</h4><p>正如所见，使用一丢丢Git命令来复制一套传统的SVN开发环境也是可以的。这对于从SVN转变而来的团队来说很棒，但这样没有利用到Git分布式的本质。   </p>
<p>如果你的团队已经习惯你了中心化的工作流，但希望提高协作效率，那么探索Feature分支工作流的好处是完全值当的。每个功能在专门的独立分支上进行，在代码并入官方项目之前就可以启动围绕新修改的深度讨论。   </p>
<h2 id="二、Feature分支的工作流"><a href="#二、Feature分支的工作流" class="headerlink" title="二、Feature分支的工作流"></a>二、Feature分支的工作流</h2><p><img src="http://p6nfblqvu.bkt.clouddn.com/gitf09.png" alt="gitf09"><br>一旦你掌握了中心化工作流的使用方法，在你的开发流程中添加功能分支是一个简单的方式来促进协作和开发者之间的交流。这种封装使得多个开发者专注自己的功能而不会打扰主代码库。它还保证master分支永远不会包含损坏的代码，给持续集成环境带来了很大的好处。<br>封装功能的开发使得Pull Request的使用成为可能，用来启动围绕一个分支的讨论。它给了其他开发者在功能并入主项目之前参与决策的机会。或者，如果你开发功能时卡在一半，你可以发起一个Pull Request，向同事寻求建议。重点是，Pull Request 使得你的团队在评论其他人的工作时变得非常简单。     </p>
<h3 id="1、如何工作"><a href="#1、如何工作" class="headerlink" title="1、如何工作"></a>1、如何工作</h3><p>Feature分支工作流同样会使用中央仓库，master同样代表官方的项目历史。但是，与其直接提交在本地的master分支，开发者每次进行新的工作时创建一个新的分支。Feature分支应该包含描述性的名称，比如animated-menu-items（菜单项动画）或issue-#1061。每个分支都应该有一个清晰，高度集中的目的。<br>Git在技术上无法区别master和功能分支，所以开发者可以在feature分支上编辑、缓存、提交，就和中心化工作流中一样。   </p>
<p>此外，feature分支可以（也应该）被推送到中央仓库中。这使得你和其他开发者共享这个功能，而又不改变官方代码。既然master只是一个“特殊”的分支，在中央仓库中存储多个feature分支不会引出什么问题。当然了，这也是备份每个开发和本地提交的好办法。   </p>
<h3 id="2、Pull-Request"><a href="#2、Pull-Request" class="headerlink" title="2、Pull Request"></a>2、Pull Request</h3><p>除了隔离功能开发之外，分支使得通过 Pull Request 讨论修改成为可能。一旦有人完成了一个功能，他们不会立即将它并入master。他们将 feature 分支推送到中央服务器上，发布一个 Pull Request，请求将他们的修改并入 master。这给了其他开发者在修改并入主代码库之前审查的机会。   </p>
<p>代码审查是 Pull Request 的主要好处，但他们事实上被设计为成为讨论代码的一般场所。你可以把 Pull Request 看作是专注某个分支的讨论版。也就是说他们可以用于开发流程之前。比如，一个开发者在某个功能上需要帮助，他只需发起一个 Pull Request。感兴趣的小伙伴会自动收到通知，看到相关提交中的问题。   </p>
<p>一旦 Pull Request 被接受了，发布功能的行为和中心化的工作流是一样的。首先，确定你本地的 master 和上游的 master 已经同步。然后，将 feature分支并入 master，将更新的 master 推送回中央仓库。</p>
<h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面演示了代码审查使用到的Pull Request，但是记住Pull Request有多种用途。   </p>
<h4 id="（1）、三人团队，有一个中央仓库"><a href="#（1）、三人团队，有一个中央仓库" class="headerlink" title="（1）、三人团队，有一个中央仓库"></a>（1）、三人团队，有一个中央仓库</h4><p>项目负责人在github上创建了一个中央仓库，三个开发人员把仓库克隆到本地中。每个人分别负责开发一个功能，都在本地创建一个分支，在这个分支上进行功能的开发。   </p>
<h4 id="（2）、A进行新功能的开发"><a href="#（2）、A进行新功能的开发" class="headerlink" title="（2）、A进行新功能的开发"></a>（2）、A进行新功能的开发</h4><p>在他开始一个功能之前，需要一个独立的分支。使用下面面的命令：   </p>
<blockquote>
<p>git checkout -b a-feature master</p>
</blockquote>
<p>表示一个基于master、名为a-feature的分支将会被checkout，-b 标记告诉Git在分支不存在时创建它。在这个分支上，Mary和往常一样编辑、缓存、提交更改，用足够多的提交来构建这个功能</p>
<h4 id="（3）、A去吃饭了"><a href="#（3）、A去吃饭了" class="headerlink" title="（3）、A去吃饭了"></a>（3）、A去吃饭了</h4><p>Mary 在早上给她的功能添加了一些提交。在她去吃午饭前，将她的分支推送到中央仓库是个不错的想法。这是一种方便的备份，但如果Mary和其他开发者一起协作，他们也可以看到她的初始提交了。   </p>
<blockquote>
<p>git push -u origin a-feature</p>
</blockquote>
<p>这个命令将a-feature推送到中央仓库（origin），-u标记将它添加为远程跟踪的分支。在设置完跟踪的分支之后，A可以调用不带任何参数的git push来推送他的功能。   </p>
<h4 id="（4）、A完成了他的工作"><a href="#（4）、A完成了他的工作" class="headerlink" title="（4）、A完成了他的工作"></a>（4）、A完成了他的工作</h4><p>当 Mary 吃完午饭回来，她完成了她的功能。在并入 master 之前，她需要发布一个 Pull Request，让其他的团队成员知道她所做的工作。但首先，她应该保证中央仓库包含了她最新的提交：   </p>
<blockquote>
<p>git push</p>
</blockquote>
<p>然后，她在她的 Git 界面上发起了一个 Pull Request，请求将 marys-feature 合并进 master，团队成员会收到自动的通知。Pull Request 的好处是，评论显示在相关的提交正下方，方便讨论特定的修改。   </p>
<h4 id="（5）、B收到了-Pull-Request"><a href="#（5）、B收到了-Pull-Request" class="headerlink" title="（5）、B收到了 Pull Request"></a>（5）、B收到了 Pull Request</h4><p>B收到了 Pull Request，并且查看了 marys-feature。他决定在并入官方项目之前做一些小修改，通过 Pull Request 和 Mary 进行了沟通。   </p>
<h4 id="（6）、A-作了修改"><a href="#（6）、A-作了修改" class="headerlink" title="（6）、A 作了修改"></a>（6）、A 作了修改</h4><p>为了做这些更改，Mary 重复了之前创建功能时相同的流程，她编辑、缓存、提交、将更新推送到中央仓库。她所有的活动显示在 Pull Request 中，B可以一直评论。<br>如果B想要的话，也可以将 marys-feature 分支 pull 到他自己的本地仓库，继续工作。后续的任何提交都会显示在 Pull Request 上。   </p>
<h4 id="（7）、A发布了她的功能"><a href="#（7）、A发布了她的功能" class="headerlink" title="（7）、A发布了她的功能"></a>（7）、A发布了她的功能</h4><p>一旦准备接受这个 Pull Request，某个人需要将功能并入稳定的项目：   </p>
<blockquote>
<p>git checkout master1<br>git pull<br>git pull origin a-feature<br>git push</p>
</blockquote>
<p>首先，不管是谁在执行合并，都要保证他们的 master 分支是最新的。然后，运行git pull origin a-feature副本。你也可以使用简单的git merge a-feature，但之前的命令保证你拉取下来的一定是功能分支最新的版本。最后，更新的master需要被推送回origin。   </p>
<p>这个过程导致了一个合并提交。一些开发者喜欢它，因为它是功能和其余代码合并的标志。但，如果你希望得到线性的历史，你可以在执行 merge 之前将功能 rebase 到 master 分支的顶端，产生一个快速向前的合并。   </p>
<p>一些界面会自动化接受 Pull Request 的流程，只需点击一下「Merge Pull Request」。如果你的没有的话，它至少在合并之后应该可以自动地关闭 Pull Request。   </p>
<h4 id="（8）、同时，C以相同的方式工作着"><a href="#（8）、同时，C以相同的方式工作着" class="headerlink" title="（8）、同时，C以相同的方式工作着"></a>（8）、同时，C以相同的方式工作着</h4><p>A和 B 一起开发 a-feature，在 Pull Request 上讨论的同时，C 还在开发他自己的 feature分支。通过将功能用不同分支隔离开来，每个人可以独立地工作，但很容易和其他开发者共享修改。</p>
<h3 id="（9）、小结"><a href="#（9）、小结" class="headerlink" title="（9）、小结"></a>（9）、小结</h3><p>现在，你应该已经看到了功能分支极大地增强了中心化工作流中单一 master 分支的作用。除此之外，功能分支还便利了 Pull Request 的使用，在版本控制界面上直接讨论特定的提交。GitFlow工作流程是管理功能开发、发布准备，维护的常见的模式。   </p>
<h2 id="三、GitFlow工作流"><a href="#三、GitFlow工作流" class="headerlink" title="三、GitFlow工作流"></a>三、GitFlow工作流</h2><p>GitFlow工作流围绕着项目发布定义了一个严格的分支模型。有些地方比功能分支工作流程更复杂，为管理大型项目提供的框架。   </p>
<h3 id="（1）、如何工作"><a href="#（1）、如何工作" class="headerlink" title="（1）、如何工作"></a>（1）、如何工作</h3><p>GitFlow工作流仍然使用中央仓库作为开发者沟通的中心。和其他工作流一样，开发者在本地工作，将分支推送到中央仓库。唯一的区别在于项目的分支结构。    </p>
<h3 id="（2）、历史分支"><a href="#（2）、历史分支" class="headerlink" title="（2）、历史分支"></a>（2）、历史分支</h3><p>和单独的master分支不同，这种工作流使用两个分支来记录项目历史。master分支储存官方发布历史，develop分支用来整合功能分支。同时，这还方便了在master分支上给所有提交打上版本号标签。    </p>
<p>工作流剩下的部分围绕这两个分支的差别展开。   </p>
<h3 id="（3）、功能分支（Feature）"><a href="#（3）、功能分支（Feature）" class="headerlink" title="（3）、功能分支（Feature）"></a>（3）、功能分支（Feature）</h3><p>每个新功能都放置在自己的分支中，可以在备份/协作时推送到中央仓库。但是，预期合并到master，功能分支将开发分支作为父分支。当一个功能完成时，它将被合并会develop分支中。功能永远不应该直接在master上交互。   </p>
<p>注意，功能分支加上develop分支就是我们之前所说的功能分支工作流。但是，GitFlow工作流不止于此。   </p>
<h3 id="（4）、发布分支（Release）"><a href="#（4）、发布分支（Release）" class="headerlink" title="（4）、发布分支（Release）"></a>（4）、发布分支（Release）</h3><p>一旦develop分支的新功能足够发布（或者预先确定的发布日期即将到来），你可以从develop分支fork一个发布分支。这个分支的创建开始了下个发布周期，只有和发布相关的任务应该在这个分支进行，如修复bug，生成文档等。一旦准备好了发布，发布分支将合并进master，打上版本号的标签。另外，它也应该合并回develop，后者可能在发布之后有了新的进展。   </p>
<p>使用一个专门的分支来准备发布确保一个团队完善当前发布，其他团队可以继续开发下一个发布的功能。它还建立了清晰的开发的开发阶段（比如说，这周我们准备4.0版本的发布，而我们在仓库的结构中也能看到这个阶段）。   </p>
<p>通常我们约定：   </p>
<ul>
<li>从develop创建分支</li>
<li>合并进master分支</li>
<li>命名规范release-<em> or release/</em></li>
</ul>
<h3 id="（5）、维护分支（Maintenance）"><a href="#（5）、维护分支（Maintenance）" class="headerlink" title="（5）、维护分支（Maintenance）"></a>（5）、维护分支（Maintenance）</h3><p>维护或者紧急修复分支用来快速给产品发布打上补丁。这是唯一可以从master上fork的分支。一旦修复完成了，它应该被并入master和develop分支（或者当前的发布分支），master应该打上更新的版本号的标签。   </p>
<p>有一个专门的bug修复开发线使得你的团队能够处理issues，而不打断其他工作流或是要等到下一个发布周期。你可以将维护分支看作在master分支上工作流的临时发布分支。   </p>
<h3 id="（6）、例子"><a href="#（6）、例子" class="headerlink" title="（6）、例子"></a>（6）、例子</h3><p>下面的例子演示了这种工作流如何用来管理发布周期。假设你已经创建了中央仓库。   </p>
<h4 id="1-创建一个开发分支（develop）"><a href="#1-创建一个开发分支（develop）" class="headerlink" title="1. 创建一个开发分支（develop）"></a>1. 创建一个开发分支（develop）</h4><p>你要做的第一步是为默认的master分支创建一个互补的develop分支。最简单的办法是在本地创建一个空的develop分支，将它推送到服务器上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch develop</span><br><span class="line">$ git push -u origin develop</span><br></pre></td></tr></table></figure></p>
<p>这个分支将会包含项目中所有的历史，而master将包含不完全版本。其他开发者应该将中央仓库克隆到本地，创建一个分支来追踪develop分支：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone url</span><br><span class="line">$ git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure></p>
<p>现在所有人都有了一份历史分支的本地副本。   </p>
<h4 id="2-A和B开始了新功能"><a href="#2-A和B开始了新功能" class="headerlink" title="2. A和B开始了新功能"></a>2. A和B开始了新功能</h4><p>我们的例子从A和B在不同分支上工作开始。他们都要为自己的功能创建单独的分支。它们的功能分支都应该基于develop，而不是master：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b a-feature develop</span><br></pre></td></tr></table></figure></p>
<p>他们都使用编辑，缓存，提交的一般约定来向功能分支添加提交：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add &lt;some-file&gt;</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure></p>
<h4 id="3、A完成了她的功能"><a href="#3、A完成了她的功能" class="headerlink" title="3、A完成了她的功能"></a>3、A完成了她的功能</h4><p>在添加一些提交之后，Merry确信她的功能以及准备好了。如果她的团队使用Pull Request，现在正是发起Pull Request的好时候，请求将她的功能并入develop分支。否则，她可以向下面一样将它并入本地的develop分支，推送到中央仓库：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin develop</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge some-feature</span><br><span class="line">$ git push</span><br><span class="line">$ git branch -d some-feature</span><br></pre></td></tr></table></figure></p>
<p>第一个命令在尝试并入功能分支之前确保develop分支已是最新。注意，功能绝不该被直接并入master。冲突的处理方式和中心化工作流相同。    </p>
<h4 id="4-A开始准备发布"><a href="#4-A开始准备发布" class="headerlink" title="4. A开始准备发布"></a>4. A开始准备发布</h4><p>当B仍然在他的功能上工作时，A开始准备项目的第一个官方发布。和开发功能一样，她新建了一个分支来封装发布的准备工作。这也是发布的版本号创建的一步：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release<span class="number">-0.1</span> develop</span><br></pre></td></tr></table></figure>
<p>这个分支用来整理提交，充分测试，更新文档，为即将到来的发布做各种准备。它就像是一个专门用来完善发布的功能分支。   </p>
<p>一旦A创建了这个分支，推送到中央仓库，这次发布的功能便被锁定了，不在develop分支中的功能将被推迟到下一个发布周期。   </p>
<h4 id="5-A完成了她的发布"><a href="#5-A完成了她的发布" class="headerlink" title="5. A完成了她的发布"></a>5. A完成了她的发布</h4><p>一旦发布准备稳妥，A将它并入master和develop，然后删除发布分支。合并回develop很重要，因为可能已经有关键的更新添加到发布分支上，而开发新功能需要用到它们。同样的，如果A的团队重视代码审查，现在将是发起Pull Reuqest的完美时机。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge release<span class="number">-0.1</span></span><br><span class="line">$ git push</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge release<span class="number">-0.1</span></span><br><span class="line">$ git push</span><br><span class="line">$ git branch -d release<span class="number">-0.1</span></span><br></pre></td></tr></table></figure>
<p>发布分支是功能开发（develop）和公开发布（master）之间的过渡阶段。不论什么时候将提交并入 master 时，你应该为提交打上方便引用的标签：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a <span class="number">0.1</span> -m<span class="string">"Initial public release"</span> master</span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure></p>
<p>Git 提供了许多钩子，即仓库中特定事件发生时被执行的脚本。当你向中央仓库推送 master 分支或者标签时，你可以配置一个钩子来自动化构建公开发布。</p>
<h4 id="6-终端用户发现了一个bug"><a href="#6-终端用户发现了一个bug" class="headerlink" title="6. 终端用户发现了一个bug"></a>6. 终端用户发现了一个bug</h4><p>正式发布之后，A回过头来和B一起为下一个发布开发功能。这时，一个终端用户开了一个issue抱怨说当前发布中存在一个bug。为了解决这个bug，A（或者B）从master上创建了一个维护分支，用几个提交修复这个issue，然后直接合并回master。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git  checkout -b issue-#001 master</span><br><span class="line"><span class="comment">//Fix the bug</span></span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge issue-#001</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>这和发布分支一样，维护分支包含了develop中需要的重要更新，因此A同样需要执行合并。接下来，她可以删除这个分支了：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">$ git merge issue-#001</span><br><span class="line">$ git push</span><br><span class="line">$ git branch -d issue-#001</span><br></pre></td></tr></table></figure>
<h3 id="（7）、小结"><a href="#（7）、小结" class="headerlink" title="（7）、小结"></a>（7）、小结</h3><p>现在，你已经很熟悉中心化的工作流，功能分支作工作流和GitFlow工作流。你应该已经可以抓住本地仓库，推送/拉取模式，和Git的分支和合并模型的无限潜力。   </p>
<p>请记住，教程中呈现的工作流只是可行的实践——而非工作中使用Git的金科玉律。因此，尽情地取其精华，去其糟粕吧。不变的是要让Git为你所用，而不是相反。   </p>
<h2 id="四、Fork工作流"><a href="#四、Fork工作流" class="headerlink" title="四、Fork工作流"></a>四、Fork工作流</h2><p>Fork 工作流和教程中讨论的其它工作流截然不同。与其使用唯一的服务端仓库作为「中央」代码库，它给予 每个 开发者一个服务端仓库。也就是说每个贡献者都有两个 Git 仓库，而不是一个：一个私有的本地仓库和一个公开的服务端仓库。   </p>
<p>Fork 工作流的主要优点在于贡献可以轻易地整合进项目，而不需要每个人都推送到单一的中央仓库。开发者推送到他们 自己的 服务端仓库，只有项目管理者可以推送到官方仓库。这使得管理者可以接受任何开发者的提交，却不需要给他们中央仓库的权限。   </p>
<p>结论是，这种分布式的工作流为大型、组织性强的团队（包括不可信的第三方）提供了安全的协作方式。它同时也是开源项目理想的工作流。   </p>
<h3 id="（1）、如何工作-1"><a href="#（1）、如何工作-1" class="headerlink" title="（1）、如何工作"></a>（1）、如何工作</h3><p>和其它 Git 工作流一样，Fork 工作流以一个储存在服务端的官方公开项目开场。但新的开发者想参与项目时，他们不直接克隆官方项目。   </p>
<p>取而代之地，他们 fork 一份官方项目，在服务端创建一份副本。这份新建的副本作为他们私有的公开仓库——没有其他开发者可以在上面推送，但他们可以从上面拉取修改（在后面我们会讨论为什么这一点很重要）。在他们创建了服务端副本之后，开发者执行 git clone 操作，在他们的本地机器上复制一份。这是他们私有的开发环境，正如其他工作流中一样。   </p>
<p>当他们准备好发布本地提交时，他们将提交推送到自己的公开仓库——而非官方仓库。然后，他们向主仓库发起一个 Pull Request，让项目维护者知道一个更新做好了合并的准备。如果贡献的代码有什么问题的话，Pull Request 可以作为一个方便的讨论版。   </p>
<p>我为了将功能并入官方代码库，维护者将贡献者的修改拉取到他们的本地仓库，确保修改不会破坏项目，将它合并到本地的 master 分支，然后将 master 分支推送到服务端的官方仓库。贡献现在已是项目的一部分，其他开发者应该从官方仓库拉取并同步他们的本地仓库。   </p>
<h3 id="（2）、中央仓库"><a href="#（2）、中央仓库" class="headerlink" title="（2）、中央仓库"></a>（2）、中央仓库</h3><p>「官方」仓库这个概念在 Fork 工作流中只是一个约定，理解这一点很重要。从技术的角度，Git 并看不出每个开发者和官方的公开仓库有什么区别。事实上，官方仓库唯一官方的原因是，它是项目维护者的仓库。    </p>
<h3 id="（3）、Fork工作流中的分支"><a href="#（3）、Fork工作流中的分支" class="headerlink" title="（3）、Fork工作流中的分支"></a>（3）、Fork工作流中的分支</h3><p>所有这些个人的公开仓库只是一个在开发者之间共享分支的约定。每个人仍然可以使用分支来隔离功能，就像在功能分支工作流和 GitFlow 工作流中一样。唯一的区别在于这些分支是如何开始的。在 Fork 工作流中，它们从另一个开发者的本地仓库拉取而来，而在功能分支和 GitFlow 分支它们被推送到官方仓库。    </p>
<h3 id="（4）、例子"><a href="#（4）、例子" class="headerlink" title="（4）、例子"></a>（4）、例子</h3><h4 id="1-项目维护者初始化了中央仓库"><a href="#1-项目维护者初始化了中央仓库" class="headerlink" title="1. 项目维护者初始化了中央仓库"></a>1. 项目维护者初始化了中央仓库</h4><p>和任何基于 Git 的项目一样，第一步是在服务端创建一个可以被所有项目成员访问到的官方仓库。一般来说，这个仓库同时还是项目维护者的公开仓库。   </p>
<h4 id="2-开发者fork仓库"><a href="#2-开发者fork仓库" class="headerlink" title="2. 开发者fork仓库"></a>2. 开发者fork仓库</h4><p>接下来，所有开发者需要 fork 官方仓库。你可以用 SSH 到服务器，运行 git clone 将它复制到服务器的另一个地址—— fork 其实只是服务端的 clone。但同样地，GitHub上开发者只需点一点按钮就可以 fork 仓库。    </p>
<p>在这步之后，每个开发者应该都有了自己的服务端仓库。像官方仓库一样，所有这些仓库都应该是裸仓库。   </p>
<h4 id="3-开发者将-fork-的仓库克隆到本地"><a href="#3-开发者将-fork-的仓库克隆到本地" class="headerlink" title="3. 开发者将 fork 的仓库克隆到本地"></a>3. 开发者将 fork 的仓库克隆到本地</h4><p>接下来开发者需要克隆他们自己的公开仓库。他们可以用熟悉的 git clone 命令来完成这一步。<br>我们的栗子假设使用他们使用 GitHub 来托管仓库。记住，在这种情况下，每个开发者应该有他们自己的 GitHub 账号，应该用下面的命令克隆服务端仓库：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:<span class="comment">//user@github.com/user/repo.git</span></span><br></pre></td></tr></table></figure></p>
<p>而教程中的其他工作流使用单一的 origin 远程连接，指向中央仓库，Fork 工作流需要两个远程连接，一个是中央仓库，另一个是开发者个人的服务端仓库。你可以给这些远端取任何名字，约定的做法是将 origin 作为你 fork 后的仓库的远端（运行 git clone 是会自动创建）和 upstream 作为官方项目。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream https:<span class="comment">//github.com/maintainer/repo</span></span><br></pre></td></tr></table></figure>
<p>你需要使用上面的命令来创建上游仓库的远程连接。它使得你轻易地保持本地仓库和官方仓库的进展同步。注意如果你的上游仓库开启了认证（比如它没有开源），你需要提供一个用户名，就像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream https:<span class="comment">//user@bitbucket.org/maintainer/repo.git</span></span><br></pre></td></tr></table></figure></p>
<p>它需要用户从官方代码库克隆或拉取之前提供有效的密码。   </p>
<h4 id="4-开发者进行自己的开发"><a href="#4-开发者进行自己的开发" class="headerlink" title="4.开发者进行自己的开发"></a>4.开发者进行自己的开发</h4><p>在他们刚克隆的本地仓库中，开发者可以编辑代码、提交更改，和其它分支中一样创建分支：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b some-feature</span><br><span class="line"><span class="comment">//编辑代码</span></span><br><span class="line">$ git commit -a -m<span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure></p>
<p>他们所有的更改在推送到公开仓库之前都是完全私有的。而且，如果官方项目已经向前进展了，他们可以用 git pull 获取新的提交：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure></p>
<p>因为开发者应该在专门的功能分支开发，这一般会产生一个快速向前的合并。    </p>
<h4 id="5-开发者发布他们的功能"><a href="#5-开发者发布他们的功能" class="headerlink" title="5.开发者发布他们的功能"></a>5.开发者发布他们的功能</h4><p>一旦开发者准备好共享他们的新功能，他们需要做两件事情。第一，他们必须将贡献的代码推送到自己的公开仓库，让其他开发者能够访问到。他们的 origin 远端应该已经设置好了，所以他们只需要：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin feature-branch</span><br></pre></td></tr></table></figure></p>
<p>这和其他工作流不同之处在于,origin 远端指向开发者个人的服务端仓库，而不是主代码库。    </p>
<p>第二，他们需要通知项目维护者，他们想要将功能并入官方代码库。GitHub 提供了一个「New Pull Request」按钮，跳转到一个网页，让你指明想要并入主仓库的分支。一般来说，你希望将功能分支并入上游远端的 master 分支。    </p>
<h4 id="6-项目维护者整合他们的功能"><a href="#6-项目维护者整合他们的功能" class="headerlink" title="6.项目维护者整合他们的功能"></a>6.项目维护者整合他们的功能</h4><p>当项目维护者收到 Pull Request 时，他们的工作是决定是否将它并入官方的代码库。他们可以使用下面两种方式之一：   </p>
<ol>
<li>直接检查 Pull Request 中检查代码</li>
<li>将代码拉取到本地仓库然后手动合并</li>
</ol>
<p>第一个选项更简单，让维护者查看修改前后的差异，在上面评论，然后通过图形界面执行合并。然而，如果 Pull Request 会导致合并冲突，第二个选项就有了必要。在这个情况中，维护者需要从开发者的服务端仓库 fetch 功能分支，合并到他们本地的 master 分支，然后解决冲突：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch https:<span class="comment">//bitbucket.org/user/repo feature-branch</span></span><br><span class="line"><span class="comment">//检查修改</span></span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge FETCH_HEAD</span><br></pre></td></tr></table></figure></p>
<p>一旦修改被整合进本地的 master，维护者需要将它推送到服务器上的官方仓库，这样其他开发者也可以访问它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>记住，维护者的 origin 指向他们的公开仓库，也就是项目的官方代码库。开发者的贡献现在完全并入了项目。    </p>
<h4 id="7-开发者和中央仓库保持同步"><a href="#7-开发者和中央仓库保持同步" class="headerlink" title="7. 开发者和中央仓库保持同步"></a>7. 开发者和中央仓库保持同步</h4><p>因为主代码库已经取得了新的进展，其他开发者应该和官方仓库同步：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull upstrame master</span><br></pre></td></tr></table></figure></p>
<h3 id="（5）、小结"><a href="#（5）、小结" class="headerlink" title="（5）、小结"></a>（5）、小结</h3><p>如果你从 SVN 迁移而来，Fork 工作流看上去是一个比较大的转变。但不要害怕——它只是在 Feature 分支工作流之上引入了一层抽象。贡献的代码发布到开发者在服务端自己的仓库，而不是在唯一的中央仓库中直接共享分支。    </p>
<p>这篇文章解释了一次代码贡献是如何从一个开发者流入官方的 master 分支的，但相同的方法可以用在将代码贡献整合进任何仓库。比如，如果你团队的一部分成员在一个特定功能上协作，他们可以用自己约定的行为共享修改——而不改变主仓库。    </p>
<p>这使得 Fork 工作流对于松散的团队来说是个非常强大的工具。任何开发者都可以轻而易举地和其他开发者共享修改，任何分支都能高效地并入主代码库。    </p>
<p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83" target="_blank" rel="noopener">原文地址</a>   </p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.png" alt="稻香Snowy wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="稻香Snowy 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/git/" rel="tag"><i class="fa fa-tag"></i> git</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/版本控制工具/git学习笔记五（关于pull-Request）/" rel="next" title="git学习笔记五（关于pull Request）">
                <i class="fa fa-chevron-left"></i> git学习笔记五（关于pull Request）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/版本控制工具/git在小团队中的管理流程/" rel="prev" title="git在小团队中的管理流程">
                git在小团队中的管理流程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/toux.jpg"
                alt="稻香Snowy" />
            
              <p class="site-author-name" itemprop="name">稻香Snowy</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry.Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Asiazdx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/fb5f478b1a94" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/59638598f265da6c4523c761" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-spinner"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5541828133/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-Weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、中心化的工作流"><span class="nav-number">1.</span> <span class="nav-text">一、中心化的工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-如何工作"><span class="nav-number">1.1.</span> <span class="nav-text">1.如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、管理冲突"><span class="nav-number">1.2.</span> <span class="nav-text">2、管理冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1、例子"><span class="nav-number">1.3.</span> <span class="nav-text">1、例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）、一人初始化了中央仓库"><span class="nav-number">1.3.1.</span> <span class="nav-text">（1）、一人初始化了中央仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）、所有人将仓库克隆到本地"><span class="nav-number">1.3.2.</span> <span class="nav-text">（2）、所有人将仓库克隆到本地</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）、-A在开发他的功能"><span class="nav-number">1.3.3.</span> <span class="nav-text">（3）、 A在开发他的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）、B在开发他的功能"><span class="nav-number">1.3.4.</span> <span class="nav-text">（4）、B在开发他的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）、A发布了他的功能"><span class="nav-number">1.3.5.</span> <span class="nav-text">（5）、A发布了他的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）、B试图发布他的功能"><span class="nav-number">1.3.6.</span> <span class="nav-text">（6）、B试图发布他的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（7）、B在A的提交上rebase"><span class="nav-number">1.3.7.</span> <span class="nav-text">（7）、B在A的提交上rebase</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（8）、B解决了合并冲突"><span class="nav-number">1.3.8.</span> <span class="nav-text">（8）、B解决了合并冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（9）、B成功发布了他的分支"><span class="nav-number">1.3.9.</span> <span class="nav-text">（9）、B成功发布了他的分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（10）、小结"><span class="nav-number">1.3.10.</span> <span class="nav-text">（10）、小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Feature分支的工作流"><span class="nav-number">2.</span> <span class="nav-text">二、Feature分支的工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、如何工作"><span class="nav-number">2.1.</span> <span class="nav-text">1、如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Pull-Request"><span class="nav-number">2.2.</span> <span class="nav-text">2、Pull Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、例子"><span class="nav-number">2.3.</span> <span class="nav-text">3、例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）、三人团队，有一个中央仓库"><span class="nav-number">2.3.1.</span> <span class="nav-text">（1）、三人团队，有一个中央仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）、A进行新功能的开发"><span class="nav-number">2.3.2.</span> <span class="nav-text">（2）、A进行新功能的开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）、A去吃饭了"><span class="nav-number">2.3.3.</span> <span class="nav-text">（3）、A去吃饭了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）、A完成了他的工作"><span class="nav-number">2.3.4.</span> <span class="nav-text">（4）、A完成了他的工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）、B收到了-Pull-Request"><span class="nav-number">2.3.5.</span> <span class="nav-text">（5）、B收到了 Pull Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）、A-作了修改"><span class="nav-number">2.3.6.</span> <span class="nav-text">（6）、A 作了修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（7）、A发布了她的功能"><span class="nav-number">2.3.7.</span> <span class="nav-text">（7）、A发布了她的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（8）、同时，C以相同的方式工作着"><span class="nav-number">2.3.8.</span> <span class="nav-text">（8）、同时，C以相同的方式工作着</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（9）、小结"><span class="nav-number">2.4.</span> <span class="nav-text">（9）、小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、GitFlow工作流"><span class="nav-number">3.</span> <span class="nav-text">三、GitFlow工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）、如何工作"><span class="nav-number">3.1.</span> <span class="nav-text">（1）、如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）、历史分支"><span class="nav-number">3.2.</span> <span class="nav-text">（2）、历史分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）、功能分支（Feature）"><span class="nav-number">3.3.</span> <span class="nav-text">（3）、功能分支（Feature）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）、发布分支（Release）"><span class="nav-number">3.4.</span> <span class="nav-text">（4）、发布分支（Release）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（5）、维护分支（Maintenance）"><span class="nav-number">3.5.</span> <span class="nav-text">（5）、维护分支（Maintenance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（6）、例子"><span class="nav-number">3.6.</span> <span class="nav-text">（6）、例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建一个开发分支（develop）"><span class="nav-number">3.6.1.</span> <span class="nav-text">1. 创建一个开发分支（develop）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-A和B开始了新功能"><span class="nav-number">3.6.2.</span> <span class="nav-text">2. A和B开始了新功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、A完成了她的功能"><span class="nav-number">3.6.3.</span> <span class="nav-text">3、A完成了她的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-A开始准备发布"><span class="nav-number">3.6.4.</span> <span class="nav-text">4. A开始准备发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-A完成了她的发布"><span class="nav-number">3.6.5.</span> <span class="nav-text">5. A完成了她的发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-终端用户发现了一个bug"><span class="nav-number">3.6.6.</span> <span class="nav-text">6. 终端用户发现了一个bug</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（7）、小结"><span class="nav-number">3.7.</span> <span class="nav-text">（7）、小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Fork工作流"><span class="nav-number">4.</span> <span class="nav-text">四、Fork工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）、如何工作-1"><span class="nav-number">4.1.</span> <span class="nav-text">（1）、如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）、中央仓库"><span class="nav-number">4.2.</span> <span class="nav-text">（2）、中央仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）、Fork工作流中的分支"><span class="nav-number">4.3.</span> <span class="nav-text">（3）、Fork工作流中的分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）、例子"><span class="nav-number">4.4.</span> <span class="nav-text">（4）、例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-项目维护者初始化了中央仓库"><span class="nav-number">4.4.1.</span> <span class="nav-text">1. 项目维护者初始化了中央仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-开发者fork仓库"><span class="nav-number">4.4.2.</span> <span class="nav-text">2. 开发者fork仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-开发者将-fork-的仓库克隆到本地"><span class="nav-number">4.4.3.</span> <span class="nav-text">3. 开发者将 fork 的仓库克隆到本地</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-开发者进行自己的开发"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.开发者进行自己的开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-开发者发布他们的功能"><span class="nav-number">4.4.5.</span> <span class="nav-text">5.开发者发布他们的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-项目维护者整合他们的功能"><span class="nav-number">4.4.6.</span> <span class="nav-text">6.项目维护者整合他们的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-开发者和中央仓库保持同步"><span class="nav-number">4.4.7.</span> <span class="nav-text">7. 开发者和中央仓库保持同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（5）、小结"><span class="nav-number">4.5.</span> <span class="nav-text">（5）、小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">稻香Snowy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  <div class="bg_content">
    <div class="filter"></div>
    <canvas id="canvas"></canvas>
  </div>
</body>

<script>
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var cw = canvas.width = window.innerWidth,
  cx = cw / 2;
var ch = canvas.height = window.innerHeight,
  cy = ch / 2;

ctx.fillStyle = "#999";
var linesNum = 16;
var linesRy = [];
var requestId = null;

function Line(flag) {
  this.flag = flag;
  this.a = {};
  this.b = {};
  if (flag == "v") {
    this.a.y = 0;
    this.b.y = ch;
    this.a.x = randomIntFromInterval(0, ch);
    this.b.x = randomIntFromInterval(0, ch);
  } else if (flag == "h") {
    this.a.x = 0;
    this.b.x = cw;
    this.a.y = randomIntFromInterval(0, cw);
    this.b.y = randomIntFromInterval(0, cw);
  }
  this.va = randomIntFromInterval(25, 100) / 100;
  this.vb = randomIntFromInterval(25, 100) / 100;

  this.draw = function() {
    ctx.strokeStyle = "#ccc";
    ctx.beginPath();
    ctx.moveTo(this.a.x, this.a.y);
    ctx.lineTo(this.b.x, this.b.y);
    ctx.stroke();
  }

  this.update = function() {
    if (this.flag == "v") {
      this.a.x += this.va;
      this.b.x += this.vb;
    } else if (flag == "h") {
      this.a.y += this.va;
      this.b.y += this.vb;
    }

    this.edges();
  }

  this.edges = function() {
    if (this.flag == "v") {
      if (this.a.x < 0 || this.a.x > cw) {
        this.va *= -1;
      }
      if (this.b.x < 0 || this.b.x > cw) {
        this.vb *= -1;
      }
    } else if (flag == "h") {
      if (this.a.y < 0 || this.a.y > ch) {
        this.va *= -1;
      }
      if (this.b.y < 0 || this.b.y > ch) {
        this.vb *= -1;
      }
    }
  }

}

for (var i = 0; i < linesNum; i++) {
  var flag = i % 2 == 0 ? "h" : "v";
  var l = new Line(flag);
  linesRy.push(l);
}

function Draw() {
  requestId = window.requestAnimationFrame(Draw);
  ctx.clearRect(0, 0, cw, ch);

  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    l.draw();
    l.update();
  }
  for (var i = 0; i < linesRy.length; i++) {
    var l = linesRy[i];
    for (var j = i + 1; j < linesRy.length; j++) {
      var l1 = linesRy[j]
      Intersect2lines(l, l1);
    }
  }
}

function Init() {
  linesRy.length = 0;
  for (var i = 0; i < linesNum; i++) {
    var flag = i % 2 == 0 ? "h" : "v";
    var l = new Line(flag);
    linesRy.push(l);
  }

  if (requestId) {
    window.cancelAnimationFrame(requestId);
    requestId = null;
  }

  cw = canvas.width = window.innerWidth,
    cx = cw / 2;
  ch = canvas.height = window.innerHeight,
    cy = ch / 2;

  Draw();
};

setTimeout(function() {
  Init();

  addEventListener('resize', Init, false);
}, 15);

function Intersect2lines(l1, l2) {
  var p1 = l1.a,
    p2 = l1.b,
    p3 = l2.a,
    p4 = l2.b;
  var denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
  var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
  var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
  var x = p1.x + ua * (p2.x - p1.x);
  var y = p1.y + ua * (p2.y - p1.y);
  if (ua > 0 && ub > 0) {
    markPoint({
      x: x,
      y: y
    })
  }
}

function markPoint(p) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
  ctx.fill();
}

function randomIntFromInterval(mn, mx) {
  return ~~(Math.random() * (mx - mn + 1) + mn);
}

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/canvasline.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</script>
</html>
